import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/highcharts/modules/accessibility.js
var require_accessibility = __commonJS({
  "node_modules/highcharts/modules/accessibility.js"(exports, module) {
    !function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/accessibility", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(t2, e2, i2, s) {
        t2.hasOwnProperty(e2) || (t2[e2] = s.apply(null, i2), "function" == typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: e2, module: t2[e2] } })));
      }
      i(e, "Accessibility/Utils/HTMLUtilities.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { doc: i2, win: s } = t2, { css: n } = e2, o = s.EventTarget && new s.EventTarget() || "none";
        function r(t3) {
          if ("function" == typeof s.MouseEvent)
            return new s.MouseEvent(t3.type, t3);
          if (i2.createEvent) {
            let e3 = i2.createEvent("MouseEvent");
            if (e3.initMouseEvent)
              return e3.initMouseEvent(t3.type, t3.bubbles, t3.cancelable, t3.view || s, t3.detail, t3.screenX, t3.screenY, t3.clientX, t3.clientY, t3.ctrlKey, t3.altKey, t3.shiftKey, t3.metaKey, t3.button, t3.relatedTarget), e3;
          }
          return a(t3.type);
        }
        function a(t3, e3, n2) {
          let r2 = e3 || { x: 0, y: 0 };
          if ("function" == typeof s.MouseEvent)
            return new s.MouseEvent(t3, { bubbles: true, cancelable: true, composed: true, button: 0, buttons: 1, relatedTarget: n2 || o, view: s, detail: "click" === t3 ? 1 : 0, screenX: r2.x, screenY: r2.y, clientX: r2.x, clientY: r2.y });
          if (i2.createEvent) {
            let e4 = i2.createEvent("MouseEvent");
            if (e4.initMouseEvent)
              return e4.initMouseEvent(t3, true, true, s, "click" === t3 ? 1 : 0, r2.x, r2.y, r2.x, r2.y, false, false, false, false, 0, null), e4;
          }
          return { type: t3 };
        }
        return { addClass: function(t3, e3) {
          t3.classList ? t3.classList.add(e3) : 0 > t3.className.indexOf(e3) && (t3.className += " " + e3);
        }, cloneMouseEvent: r, cloneTouchEvent: function(t3) {
          let e3 = (t4) => {
            let e4 = [];
            for (let i4 = 0; i4 < t4.length; ++i4) {
              let s2 = t4.item(i4);
              s2 && e4.push(s2);
            }
            return e4;
          };
          if ("function" == typeof s.TouchEvent) {
            let i4 = new s.TouchEvent(t3.type, { touches: e3(t3.touches), targetTouches: e3(t3.targetTouches), changedTouches: e3(t3.changedTouches), ctrlKey: t3.ctrlKey, shiftKey: t3.shiftKey, altKey: t3.altKey, metaKey: t3.metaKey, bubbles: t3.bubbles, cancelable: t3.cancelable, composed: t3.composed, detail: t3.detail, view: t3.view });
            return t3.defaultPrevented && i4.preventDefault(), i4;
          }
          let i3 = r(t3);
          return i3.touches = t3.touches, i3.changedTouches = t3.changedTouches, i3.targetTouches = t3.targetTouches, i3;
        }, escapeStringForHTML: function(t3) {
          return t3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
        }, getElement: function(t3) {
          return i2.getElementById(t3);
        }, getFakeMouseEvent: a, getHeadingTagNameForElement: function(t3) {
          let e3 = (t4) => {
            let e4 = parseInt(t4.slice(1), 10);
            return "h" + Math.min(6, e4 + 1);
          }, i3 = (t4) => /H[1-6]/.test(t4), s2 = (t4) => {
            let e4 = t4;
            for (; e4 = e4.previousSibling; ) {
              let t5 = e4.tagName || "";
              if (i3(t5))
                return t5;
            }
            return "";
          }, n2 = (t4) => {
            let o2 = s2(t4);
            if (o2)
              return e3(o2);
            let r2 = t4.parentElement;
            if (!r2)
              return "p";
            let a2 = r2.tagName;
            return i3(a2) ? e3(a2) : n2(r2);
          };
          return n2(t3);
        }, removeChildNodes: function(t3) {
          for (; t3.lastChild; )
            t3.removeChild(t3.lastChild);
        }, removeClass: function(t3, e3) {
          t3.classList ? t3.classList.remove(e3) : t3.className = t3.className.replace(RegExp(e3, "g"), "");
        }, removeElement: function(t3) {
          t3 && t3.parentNode && t3.parentNode.removeChild(t3);
        }, reverseChildNodes: function(t3) {
          let e3 = t3.childNodes.length;
          for (; e3--; )
            t3.appendChild(t3.childNodes[e3]);
        }, simulatedEventTarget: o, stripHTMLTagsFromString: function(t3, e3 = false) {
          return "string" == typeof t3 ? e3 ? t3.replace(/<\/?[^>]+(>|$)/g, "") : t3.replace(/<\/?(?!\s)[^>]+(>|$)/g, "") : t3;
        }, visuallyHideElement: function(t3) {
          n(t3, { position: "absolute", width: "1px", height: "1px", overflow: "hidden", whiteSpace: "nowrap", clip: "rect(1px, 1px, 1px, 1px)", marginTop: "-3px", "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)", filter: "alpha(opacity=1)", opacity: 0.01 });
        } };
      }), i(e, "Accessibility/A11yI18n.js", [e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        var s;
        let { format: n } = t2, { composed: o } = e2, { getNestedProperty: r, pick: a, pushUnique: l } = i2;
        return function(t3) {
          function e3(t4, e4, i4) {
            let s2 = (t5, e5) => {
              let i5 = t5.slice(e5 || 0), s3 = i5.indexOf("{"), n2 = i5.indexOf("}");
              if (s3 > -1 && n2 > s3)
                return { statement: i5.substring(s3 + 1, n2), begin: e5 + s3 + 1, end: e5 + n2 };
            }, o2 = [], l2, h, c = 0;
            do
              l2 = s2(t4, c), (h = t4.substring(c, l2 && l2.begin - 1)).length && o2.push({ value: h, type: "constant" }), l2 && o2.push({ value: l2.statement, type: "statement" }), c = l2 ? l2.end + 1 : c + 1;
            while (l2);
            return o2.forEach((t5) => {
              "statement" === t5.type && (t5.value = function(t6, e5) {
                let i5, s3;
                let n2 = t6.indexOf("#each("), o3 = t6.indexOf("#plural("), l3 = t6.indexOf("["), h2 = t6.indexOf("]");
                if (n2 > -1) {
                  let o4 = t6.slice(n2).indexOf(")") + n2, a2 = t6.substring(0, n2), l4 = t6.substring(o4 + 1), h3 = t6.substring(n2 + 6, o4), c3 = h3.split(","), d = Number(c3[1]), u;
                  if (s3 = "", i5 = r(c3[0], e5)) {
                    u = (d = isNaN(d) ? i5.length : d) < 0 ? i5.length + d : Math.min(d, i5.length);
                    for (let t7 = 0; t7 < u; ++t7)
                      s3 += a2 + i5[t7] + l4;
                  }
                  return s3.length ? s3 : "";
                }
                if (o3 > -1) {
                  var c2;
                  let i6 = t6.slice(o3).indexOf(")") + o3, n3 = t6.substring(o3 + 8, i6), l4 = n3.split(","), h3 = Number(r(l4[0], e5));
                  switch (h3) {
                    case 0:
                      s3 = a(l4[4], l4[1]);
                      break;
                    case 1:
                      s3 = a(l4[2], l4[1]);
                      break;
                    case 2:
                      s3 = a(l4[3], l4[1]);
                      break;
                    default:
                      s3 = l4[1];
                  }
                  return s3 ? (c2 = s3).trim && c2.trim() || c2.replace(/^\s+|\s+$/g, "") : "";
                }
                if (l3 > -1) {
                  let s4;
                  let n3 = t6.substring(0, l3), o4 = Number(t6.substring(l3 + 1, h2));
                  return i5 = r(n3, e5), !isNaN(o4) && i5 && (o4 < 0 ? void 0 === (s4 = i5[i5.length + o4]) && (s4 = i5[0]) : void 0 === (s4 = i5[o4]) && (s4 = i5[i5.length - 1])), void 0 !== s4 ? s4 : "";
                }
                return "{" + t6 + "}";
              }(t5.value, e4));
            }), n(o2.reduce((t5, e5) => t5 + e5.value, ""), e4, i4);
          }
          function i3(t4, i4) {
            let s2 = t4.split("."), n2 = this.options.lang, o2 = 0;
            for (; o2 < s2.length; ++o2)
              n2 = n2 && n2[s2[o2]];
            return "string" == typeof n2 ? e3(n2, i4, this) : "";
          }
          t3.compose = function t4(e4) {
            if (l(o, t4)) {
              let t5 = e4.prototype;
              t5.langFormat = i3;
            }
          }, t3.i18nFormat = e3;
        }(s || (s = {})), s;
      }), i(e, "Accessibility/Utils/ChartUtilities.js", [e["Core/Globals.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { doc: s } = t2, { stripHTMLTagsFromString: n } = e2, { defined: o, find: r, fireEvent: a } = i2;
        function l(t3) {
          if (t3.points && t3.points.length) {
            let e3 = r(t3.points, (t4) => !!t4.graphic);
            return e3 && e3.graphic && e3.graphic.element;
          }
        }
        function h(t3) {
          let e3 = l(t3);
          return e3 && e3.parentNode || t3.graph && t3.graph.element || t3.group && t3.group.element;
        }
        return { fireEventOnWrappedOrUnwrappedElement: function t3(e3, i3) {
          let n2 = i3.type, o2 = e3.hcEvents;
          s.createEvent && (e3.dispatchEvent || e3.fireEvent) ? e3.dispatchEvent ? e3.dispatchEvent(i3) : e3.fireEvent(n2, i3) : o2 && o2[n2] ? a(e3, n2, i3) : e3.element && t3(e3.element, i3);
        }, getChartTitle: function(t3) {
          return n(t3.options.title.text || t3.langFormat("accessibility.defaultChartTitle", { chart: t3 }), t3.renderer.forExport);
        }, getAxisDescription: function(t3) {
          var _a, _b;
          return t3 && (((_a = t3.options.accessibility) == null ? void 0 : _a.description) || ((_b = t3.axisTitle) == null ? void 0 : _b.textStr) || t3.options.id || t3.categories && "categories" || t3.dateTime && "Time" || "values");
        }, getAxisRangeDescription: function(t3) {
          let e3 = t3.options || {};
          return e3.accessibility && void 0 !== e3.accessibility.rangeDescription ? e3.accessibility.rangeDescription : t3.categories ? function(t4) {
            let e4 = t4.chart;
            return t4.dataMax && t4.dataMin ? e4.langFormat("accessibility.axis.rangeCategories", { chart: e4, axis: t4, numCategories: t4.dataMax - t4.dataMin + 1 }) : "";
          }(t3) : t3.dateTime && (0 === t3.min || 0 === t3.dataMin) ? function(t4) {
            let e4 = t4.chart, i3 = {}, s2 = t4.dataMin || t4.min || 0, n2 = t4.dataMax || t4.max || 0, o2 = "Seconds";
            i3.Seconds = (n2 - s2) / 1e3, i3.Minutes = i3.Seconds / 60, i3.Hours = i3.Minutes / 60, i3.Days = i3.Hours / 24, ["Minutes", "Hours", "Days"].forEach(function(t5) {
              i3[t5] > 2 && (o2 = t5);
            });
            let r2 = i3[o2].toFixed("Seconds" !== o2 && "Minutes" !== o2 ? 1 : 0);
            return e4.langFormat("accessibility.axis.timeRange" + o2, { chart: e4, axis: t4, range: r2.replace(".0", "") });
          }(t3) : function(t4) {
            let e4 = t4.chart, i3 = e4.options, s2 = i3 && i3.accessibility && i3.accessibility.screenReaderSection.axisRangeDateFormat || "", n2 = { min: t4.dataMin || t4.min || 0, max: t4.dataMax || t4.max || 0 }, o2 = function(i4) {
              return t4.dateTime ? e4.time.dateFormat(s2, n2[i4]) : n2[i4].toString();
            };
            return e4.langFormat("accessibility.axis.rangeFromTo", { chart: e4, axis: t4, rangeFrom: o2("min"), rangeTo: o2("max") });
          }(t3);
        }, getPointFromXY: function(t3, e3, i3) {
          let s2 = t3.length, n2;
          for (; s2--; )
            if (n2 = r(t3[s2].points || [], function(t4) {
              return t4.x === e3 && t4.y === i3;
            }))
              return n2;
        }, getSeriesFirstPointElement: l, getSeriesFromName: function(t3, e3) {
          return e3 ? (t3.series || []).filter(function(t4) {
            return t4.name === e3;
          }) : t3.series;
        }, getSeriesA11yElement: h, unhideChartElementFromAT: function t3(e3, i3) {
          i3.setAttribute("aria-hidden", false), i3 !== e3.renderTo && i3.parentNode && i3.parentNode !== s.body && (Array.prototype.forEach.call(i3.parentNode.childNodes, function(t4) {
            t4.hasAttribute("aria-hidden") || t4.setAttribute("aria-hidden", true);
          }), t3(e3, i3.parentNode));
        }, hideSeriesFromAT: function(t3) {
          let e3 = h(t3);
          e3 && e3.setAttribute("aria-hidden", true);
        }, scrollAxisToPoint: function(t3) {
          let e3 = t3.series.xAxis, i3 = t3.series.yAxis, s2 = e3 && e3.scrollbar ? e3 : i3, n2 = s2 && s2.scrollbar;
          if (n2 && o(n2.to) && o(n2.from)) {
            let e4 = n2.to - n2.from, i4 = function(t4, e5) {
              if (!o(t4.dataMin) || !o(t4.dataMax))
                return 0;
              let i5 = t4.toPixels(t4.dataMin), s3 = t4.toPixels(t4.dataMax), n3 = "xAxis" === t4.coll ? "x" : "y", r2 = t4.toPixels(e5[n3] || 0);
              return (r2 - i5) / (s3 - i5);
            }(s2, t3);
            n2.updatePosition(i4 - e4 / 2, i4 + e4 / 2), a(n2, "changed", { from: n2.from, to: n2.to, trigger: "scrollbar", DOMEvent: null });
          }
        } };
      }), i(e, "Accessibility/Utils/DOMElementProvider.js", [e["Core/Globals.js"], e["Accessibility/Utils/HTMLUtilities.js"]], function(t2, e2) {
        let { doc: i2 } = t2, { removeElement: s } = e2;
        return class {
          constructor() {
            this.elements = [];
          }
          createElement() {
            let t3 = i2.createElement.apply(i2, arguments);
            return this.elements.push(t3), t3;
          }
          destroyCreatedElements() {
            this.elements.forEach(function(t3) {
              s(t3);
            }), this.elements = [];
          }
        };
      }), i(e, "Accessibility/Utils/EventProvider.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { addEvent: i2 } = e2;
        return class {
          constructor() {
            this.eventRemovers = [];
          }
          addEvent() {
            let e3 = i2.apply(t2, arguments);
            return this.eventRemovers.push(e3), e3;
          }
          removeAddedEvents() {
            this.eventRemovers.forEach((t3) => t3()), this.eventRemovers = [];
          }
        };
      }), i(e, "Accessibility/AccessibilityComponent.js", [e["Accessibility/Utils/ChartUtilities.js"], e["Accessibility/Utils/DOMElementProvider.js"], e["Accessibility/Utils/EventProvider.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n) {
        let { fireEventOnWrappedOrUnwrappedElement: o } = t2, { getFakeMouseEvent: r } = s, { extend: a } = n;
        class l {
          initBase(t3, s2) {
            this.chart = t3, this.eventProvider = new i2(), this.domElementProvider = new e2(), this.proxyProvider = s2, this.keyCodes = { left: 37, right: 39, up: 38, down: 40, enter: 13, space: 32, esc: 27, tab: 9, pageUp: 33, pageDown: 34, end: 35, home: 36 };
          }
          addEvent(t3, e3, i3, s2) {
            return this.eventProvider.addEvent(t3, e3, i3, s2);
          }
          createElement(t3, e3) {
            return this.domElementProvider.createElement(t3, e3);
          }
          fakeClickEvent(t3) {
            let e3 = r("click");
            o(t3, e3);
          }
          destroyBase() {
            this.domElementProvider.destroyCreatedElements(), this.eventProvider.removeAddedEvents();
          }
        }
        return a(l.prototype, { init() {
        }, getKeyboardNavigation: function() {
        }, onChartUpdate() {
        }, onChartRender() {
        }, destroy() {
        } }), l;
      }), i(e, "Accessibility/KeyboardNavigationHandler.js", [e["Core/Utilities.js"]], function(t2) {
        let { find: e2 } = t2;
        return class {
          constructor(t3, e3) {
            this.chart = t3, this.keyCodeMap = e3.keyCodeMap || [], this.validate = e3.validate, this.init = e3.init, this.terminate = e3.terminate, this.response = { success: 1, prev: 2, next: 3, noHandler: 4, fail: 5 };
          }
          run(t3) {
            let i2 = t3.which || t3.keyCode, s = this.response.noHandler, n = e2(this.keyCodeMap, function(t4) {
              return t4[0].indexOf(i2) > -1;
            });
            return n ? s = n[1].call(this, i2, t3) : 9 === i2 && (s = this.response[t3.shiftKey ? "prev" : "next"]), s;
          }
        };
      }), i(e, "Accessibility/Components/ContainerComponent.js", [e["Accessibility/AccessibilityComponent.js"], e["Accessibility/KeyboardNavigationHandler.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Core/Globals.js"], e["Accessibility/Utils/HTMLUtilities.js"]], function(t2, e2, i2, s, n) {
        let { unhideChartElementFromAT: o, getChartTitle: r } = i2, { doc: a } = s, { stripHTMLTagsFromString: l } = n;
        return class extends t2 {
          onChartUpdate() {
            this.handleSVGTitleElement(), this.setSVGContainerLabel(), this.setGraphicContainerAttrs(), this.setRenderToAttrs(), this.makeCreditsAccessible();
          }
          handleSVGTitleElement() {
            let t3 = this.chart, e3 = "highcharts-title-" + t3.index, i3 = l(t3.langFormat("accessibility.svgContainerTitle", { chartTitle: r(t3) }));
            if (i3.length) {
              let s2 = this.svgTitleElement = this.svgTitleElement || a.createElementNS("http://www.w3.org/2000/svg", "title");
              s2.textContent = i3, s2.id = e3, t3.renderTo.insertBefore(s2, t3.renderTo.firstChild);
            }
          }
          setSVGContainerLabel() {
            let t3 = this.chart, e3 = t3.langFormat("accessibility.svgContainerLabel", { chartTitle: r(t3) });
            t3.renderer.box && e3.length && t3.renderer.box.setAttribute("aria-label", e3);
          }
          setGraphicContainerAttrs() {
            let t3 = this.chart, e3 = t3.langFormat("accessibility.graphicContainerLabel", { chartTitle: r(t3) });
            e3.length && t3.container.setAttribute("aria-label", e3);
          }
          setRenderToAttrs() {
            let t3 = this.chart, e3 = "disabled" !== t3.options.accessibility.landmarkVerbosity, i3 = t3.langFormat("accessibility.chartContainerLabel", { title: r(t3), chart: t3 });
            i3 && (t3.renderTo.setAttribute("role", e3 ? "region" : "group"), t3.renderTo.setAttribute("aria-label", i3));
          }
          makeCreditsAccessible() {
            let t3 = this.chart, e3 = t3.credits;
            e3 && (e3.textStr && e3.element.setAttribute("aria-label", t3.langFormat("accessibility.credits", { creditsStr: l(e3.textStr, t3.renderer.forExport) })), o(t3, e3.element));
          }
          getKeyboardNavigation() {
            let t3 = this.chart;
            return new e2(t3, { keyCodeMap: [], validate: function() {
              return true;
            }, init: function() {
              let e3 = t3.accessibility;
              e3 && e3.keyboardNavigation.tabindexContainer.focus();
            } });
          }
          destroy() {
            this.chart.renderTo.setAttribute("aria-hidden", true);
          }
        };
      }), i(e, "Accessibility/FocusBorder.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var i2;
        let { composed: s } = t2, { addEvent: n, pick: o, pushUnique: r } = e2;
        return function(t3) {
          let e3 = ["x", "y", "transform", "width", "height", "r", "d", "stroke-width"];
          function i3() {
            let t4 = this.focusElement, e4 = this.options.accessibility.keyboardNavigation.focusBorder;
            t4 && (t4.removeFocusBorder(), e4.enabled && t4.addFocusBorder(e4.margin, { stroke: e4.style.color, strokeWidth: e4.style.lineWidth, r: e4.style.borderRadius }));
          }
          function a(t4, e4) {
            let i4 = this.options.accessibility.keyboardNavigation.focusBorder, s2 = e4 || t4.element;
            s2 && s2.focus && (s2.hcEvents && s2.hcEvents.focusin || n(s2, "focusin", function() {
            }), s2.focus(), i4.hideBrowserFocusOutline && (s2.style.outline = "none")), this.focusElement && this.focusElement.removeFocusBorder(), this.focusElement = t4, this.renderFocusBorder();
          }
          function l(t4, i4) {
            this.focusBorder && this.removeFocusBorder();
            let s2 = this.getBBox(), n2 = o(t4, 3), r2 = this.parentGroup, a2 = this.scaleX || r2 && r2.scaleX, l2 = this.scaleY || r2 && r2.scaleY, h2 = a2 ? !l2 : l2, c = h2 ? Math.abs(a2 || l2 || 1) : (Math.abs(a2 || 1) + Math.abs(l2 || 1)) / 2;
            s2.x += this.translateX ? this.translateX : 0, s2.y += this.translateY ? this.translateY : 0;
            let d = s2.x - n2, u = s2.y - n2, p = s2.width + 2 * n2, g = s2.height + 2 * n2, m = !!this.text;
            if ("text" === this.element.nodeName || m) {
              let t5, e4;
              let i5 = !!this.rotation, o2 = m ? { x: i5 ? 1 : 0, y: 0 } : (t5 = 0, e4 = 0, "middle" === this.attr("text-anchor") ? t5 = e4 = 0.5 : this.rotation ? t5 = 0.25 : e4 = 0.75, { x: t5, y: e4 }), r3 = +this.attr("x"), a3 = +this.attr("y");
              if (isNaN(r3) || (d = r3 - s2.width * o2.x - n2), isNaN(a3) || (u = a3 - s2.height * o2.y - n2), m && i5) {
                let t6 = p;
                p = g, g = t6, isNaN(r3) || (d = r3 - s2.height * o2.x - n2), isNaN(a3) || (u = a3 - s2.width * o2.y - n2);
              }
            }
            this.focusBorder = this.renderer.rect(d, u, p, g, parseInt((i4 && i4.r || 0).toString(), 10) / c).addClass("highcharts-focus-border").attr({ zIndex: 99 }).add(r2), this.renderer.styledMode || this.focusBorder.attr({ stroke: i4 && i4.stroke, "stroke-width": (i4 && i4.strokeWidth || 0) / c }), function(t5, ...i5) {
              t5.focusBorderUpdateHooks || (t5.focusBorderUpdateHooks = {}, e3.forEach((e4) => {
                let s3 = e4 + "Setter", n3 = t5[s3] || t5._defaultSetter;
                t5.focusBorderUpdateHooks[s3] = n3, t5[s3] = function() {
                  let e5 = n3.apply(t5, arguments);
                  return t5.addFocusBorder.apply(t5, i5), e5;
                };
              }));
            }(this, t4, i4), function(t5) {
              if (t5.focusBorderDestroyHook)
                return;
              let e4 = t5.destroy;
              t5.destroy = function() {
                return t5.focusBorder && t5.focusBorder.destroy && t5.focusBorder.destroy(), e4.apply(t5, arguments);
              }, t5.focusBorderDestroyHook = e4;
            }(this);
          }
          function h() {
            var t4;
            t4 = this, t4.focusBorderUpdateHooks && (Object.keys(t4.focusBorderUpdateHooks).forEach((e4) => {
              let i4 = t4.focusBorderUpdateHooks[e4];
              i4 === t4._defaultSetter ? delete t4[e4] : t4[e4] = i4;
            }), delete t4.focusBorderUpdateHooks), this.focusBorderDestroyHook && (this.destroy = this.focusBorderDestroyHook, delete this.focusBorderDestroyHook), this.focusBorder && (this.focusBorder.destroy(), delete this.focusBorder);
          }
          t3.compose = function t4(e4, n2) {
            if (r(s, t4)) {
              let t5 = e4.prototype, s2 = n2.prototype;
              t5.renderFocusBorder = i3, t5.setFocusToElement = a, s2.addFocusBorder = l, s2.removeFocusBorder = h;
            }
          };
        }(i2 || (i2 = {})), i2;
      }), i(e, "Accessibility/Utils/Announcer.js", [e["Core/Renderer/HTML/AST.js"], e["Accessibility/Utils/DOMElementProvider.js"], e["Core/Globals.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n) {
        let { doc: o } = i2, { addClass: r, visuallyHideElement: a } = s, { attr: l } = n;
        return class {
          constructor(t3, i3) {
            this.chart = t3, this.domElementProvider = new e2(), this.announceRegion = this.addAnnounceRegion(i3);
          }
          destroy() {
            this.domElementProvider.destroyCreatedElements();
          }
          announce(e3) {
            t2.setElementHTML(this.announceRegion, e3), this.clearAnnouncementRegionTimer && clearTimeout(this.clearAnnouncementRegionTimer), this.clearAnnouncementRegionTimer = setTimeout(() => {
              this.announceRegion.innerHTML = t2.emptyHTML, delete this.clearAnnouncementRegionTimer;
            }, 3e3);
          }
          addAnnounceRegion(t3) {
            let e3 = this.chart.announcerContainer || this.createAnnouncerContainer(), i3 = this.domElementProvider.createElement("div");
            return l(i3, { "aria-hidden": false, "aria-live": t3, "aria-atomic": true }), this.chart.styledMode ? r(i3, "highcharts-visually-hidden") : a(i3), e3.appendChild(i3), i3;
          }
          createAnnouncerContainer() {
            let t3 = this.chart, e3 = o.createElement("div");
            return l(e3, { "aria-hidden": false, class: "highcharts-announcer-container" }), e3.style.position = "relative", t3.renderTo.insertBefore(e3, t3.renderTo.firstChild), t3.announcerContainer = e3, e3;
          }
        };
      }), i(e, "Accessibility/Components/AnnotationsA11y.js", [e["Accessibility/Utils/HTMLUtilities.js"]], function(t2) {
        let { escapeStringForHTML: e2, stripHTMLTagsFromString: i2 } = t2;
        function s(t3) {
          let e3 = t3.annotations || [];
          return e3.reduce((t4, e4) => (e4.options && false !== e4.options.visible && (t4 = t4.concat(e4.labels)), t4), []);
        }
        function n(t3) {
          return t3.options && t3.options.accessibility && t3.options.accessibility.description || t3.graphic && t3.graphic.text && t3.graphic.text.textStr || "";
        }
        function o(t3) {
          let e3 = t3.options && t3.options.accessibility && t3.options.accessibility.description;
          if (e3)
            return e3;
          let i3 = t3.chart, s2 = n(t3), o2 = t3.points, r2 = (t4) => t4.graphic && t4.graphic.element && t4.graphic.element.getAttribute("aria-label") || "", a = o2.filter((t4) => !!t4.graphic).map((t4) => {
            let e4 = t4.accessibility && t4.accessibility.valueDescription || r2(t4), i4 = t4 && t4.series.name || "";
            return (i4 ? i4 + ", " : "") + "data point " + e4;
          }).filter((t4) => !!t4), l = a.length, h = l > 1 ? "MultiplePoints" : l ? "SinglePoint" : "NoPoints", c = { annotationText: s2, annotation: t3, numPoints: l, annotationPoint: a[0], additionalAnnotationPoints: a.slice(1) };
          return i3.langFormat("accessibility.screenReaderSection.annotations.description" + h, c);
        }
        function r(t3) {
          let n2 = s(t3);
          return n2.map((s2) => {
            let n3 = e2(i2(o(s2), t3.renderer.forExport));
            return n3 ? `<li>${n3}</li>` : "";
          });
        }
        return { getAnnotationsInfoHTML: function(t3) {
          let e3 = t3.annotations;
          if (!(e3 && e3.length))
            return "";
          let i3 = r(t3);
          return `<ul style="list-style-type: none">${i3.join(" ")}</ul>`;
        }, getAnnotationLabelDescription: o, getAnnotationListItems: r, getPointAnnotationTexts: function(t3) {
          let e3 = s(t3.series.chart), i3 = e3.filter((e4) => e4.points.indexOf(t3) > -1);
          return i3.length ? i3.map((t4) => `${n(t4)}`) : [];
        } };
      }), i(e, "Accessibility/Components/InfoRegionsComponent.js", [e["Accessibility/A11yI18n.js"], e["Accessibility/AccessibilityComponent.js"], e["Accessibility/Utils/Announcer.js"], e["Accessibility/Components/AnnotationsA11y.js"], e["Core/Renderer/HTML/AST.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Core/Templating.js"], e["Core/Globals.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n, o, r, a, l, h) {
        let { getAnnotationsInfoHTML: c } = s, { getAxisDescription: d, getAxisRangeDescription: u, getChartTitle: p, unhideChartElementFromAT: g } = o, { format: m } = r, { doc: b } = a, { addClass: f, getElement: x, getHeadingTagNameForElement: y, stripHTMLTagsFromString: v, visuallyHideElement: A } = l, { attr: w, pick: C } = h;
        function E(t3) {
          return t3.replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "");
        }
        return class extends e2 {
          constructor() {
            super(...arguments), this.screenReaderSections = {};
          }
          init() {
            let t3 = this.chart, e3 = this;
            this.initRegionsDefinitions(), this.addEvent(t3, "aftergetTableAST", function(t4) {
              e3.onDataTableCreated(t4);
            }), this.addEvent(t3, "afterViewData", function(t4) {
              t4.wasHidden && (e3.dataTableDiv = t4.element, setTimeout(function() {
                e3.focusDataTable();
              }, 300));
            }), this.addEvent(t3, "afterHideData", function() {
              e3.viewDataTableButton && e3.viewDataTableButton.setAttribute("aria-expanded", "false");
            }), this.announcer = new i2(t3, "assertive");
          }
          initRegionsDefinitions() {
            let t3 = this, e3 = this.chart.options.accessibility;
            this.screenReaderSections = { before: { element: null, buildContent: function(i3) {
              let s2 = e3.screenReaderSection.beforeChartFormatter;
              return s2 ? s2(i3) : t3.defaultBeforeChartFormatter(i3);
            }, insertIntoDOM: function(t4, e4) {
              e4.renderTo.insertBefore(t4, e4.renderTo.firstChild);
            }, afterInserted: function() {
              void 0 !== t3.sonifyButtonId && t3.initSonifyButton(t3.sonifyButtonId), void 0 !== t3.dataTableButtonId && t3.initDataTableButton(t3.dataTableButtonId);
            } }, after: { element: null, buildContent: function(i3) {
              let s2 = e3.screenReaderSection.afterChartFormatter;
              return s2 ? s2(i3) : t3.defaultAfterChartFormatter();
            }, insertIntoDOM: function(t4, e4) {
              e4.renderTo.insertBefore(t4, e4.container.nextSibling);
            }, afterInserted: function() {
              t3.chart.accessibility && e3.keyboardNavigation.enabled && t3.chart.accessibility.keyboardNavigation.updateExitAnchor();
            } } };
          }
          onChartRender() {
            let t3 = this;
            this.linkedDescriptionElement = this.getLinkedDescriptionElement(), this.setLinkedDescriptionAttrs(), Object.keys(this.screenReaderSections).forEach(function(e3) {
              t3.updateScreenReaderSection(e3);
            });
          }
          getLinkedDescriptionElement() {
            let t3 = this.chart.options, e3 = t3.accessibility.linkedDescription;
            if (!e3)
              return;
            if ("string" != typeof e3)
              return e3;
            let i3 = m(e3, this.chart), s2 = b.querySelectorAll(i3);
            if (1 === s2.length)
              return s2[0];
          }
          setLinkedDescriptionAttrs() {
            let t3 = this.linkedDescriptionElement;
            t3 && (t3.setAttribute("aria-hidden", "true"), f(t3, "highcharts-linked-description"));
          }
          updateScreenReaderSection(t3) {
            let e3 = this.chart, i3 = this.screenReaderSections[t3], s2 = i3.buildContent(e3), o2 = i3.element = i3.element || this.createElement("div"), r2 = o2.firstChild || this.createElement("div");
            s2 ? (this.setScreenReaderSectionAttribs(o2, t3), n.setElementHTML(r2, s2), o2.appendChild(r2), i3.insertIntoDOM(o2, e3), e3.styledMode ? f(r2, "highcharts-visually-hidden") : A(r2), g(e3, r2), i3.afterInserted && i3.afterInserted()) : (o2.parentNode && o2.parentNode.removeChild(o2), i3.element = null);
          }
          setScreenReaderSectionAttribs(t3, e3) {
            let i3 = this.chart, s2 = i3.langFormat("accessibility.screenReaderSection." + e3 + "RegionLabel", { chart: i3, chartTitle: p(i3) }), n2 = `highcharts-screen-reader-region-${e3}-${i3.index}`;
            w(t3, { id: n2, "aria-label": s2 || void 0 }), t3.style.position = "relative", s2 && t3.setAttribute("role", "all" === i3.options.accessibility.landmarkVerbosity ? "region" : "group");
          }
          defaultBeforeChartFormatter() {
            let e3 = this.chart, i3 = e3.options.accessibility.screenReaderSection.beforeChartFormat;
            if (!i3)
              return "";
            let s2 = this.getAxesDescription(), n2 = e3.sonify && e3.options.sonification && e3.options.sonification.enabled, o2 = "highcharts-a11y-sonify-data-btn-" + e3.index, r2 = "hc-linkto-highcharts-data-table-" + e3.index, a2 = c(e3), l2 = e3.langFormat("accessibility.screenReaderSection.annotations.heading", { chart: e3 }), h2 = { headingTagName: y(e3.renderTo), chartTitle: p(e3), typeDescription: this.getTypeDescriptionText(), chartSubtitle: this.getSubtitleText(), chartLongdesc: this.getLongdescText(), xAxisDescription: s2.xAxis, yAxisDescription: s2.yAxis, playAsSoundButton: n2 ? this.getSonifyButtonText(o2) : "", viewTableButton: e3.getCSV ? this.getDataTableButtonText(r2) : "", annotationsTitle: a2 ? l2 : "", annotationsList: a2 }, d2 = t2.i18nFormat(i3, h2, e3);
            return this.dataTableButtonId = r2, this.sonifyButtonId = o2, E(d2);
          }
          defaultAfterChartFormatter() {
            let e3 = this.chart, i3 = e3.options.accessibility.screenReaderSection.afterChartFormat;
            if (!i3)
              return "";
            let s2 = { endOfChartMarker: this.getEndOfChartMarkerText() }, n2 = t2.i18nFormat(i3, s2, e3);
            return E(n2);
          }
          getLinkedDescription() {
            let t3 = this.linkedDescriptionElement, e3 = t3 && t3.innerHTML || "";
            return v(e3, this.chart.renderer.forExport);
          }
          getLongdescText() {
            let t3 = this.chart.options, e3 = t3.caption, i3 = e3 && e3.text, s2 = this.getLinkedDescription();
            return t3.accessibility.description || s2 || i3 || "";
          }
          getTypeDescriptionText() {
            let t3 = this.chart;
            return t3.types ? t3.options.accessibility.typeDescription || function(t4, e3) {
              let i3 = e3[0], s2 = t4.series && t4.series[0] || {}, n2 = t4.mapView && t4.mapView.geoMap && t4.mapView.geoMap.title, o2 = { numSeries: t4.series.length, numPoints: s2.points && s2.points.length, chart: t4, mapTitle: n2 };
              return i3 ? "map" === i3 || "tiledwebmap" === i3 ? o2.mapTitle ? t4.langFormat("accessibility.chartTypes.mapTypeDescription", o2) : t4.langFormat("accessibility.chartTypes.unknownMap", o2) : t4.types.length > 1 ? t4.langFormat("accessibility.chartTypes.combinationChart", o2) : function(t5, e4, i4) {
                let s3 = e4[0], n3 = t5.langFormat("accessibility.seriesTypeDescriptions." + s3, i4), o3 = t5.series && t5.series.length < 2 ? "Single" : "Multiple";
                return (t5.langFormat("accessibility.chartTypes." + s3 + o3, i4) || t5.langFormat("accessibility.chartTypes.default" + o3, i4)) + (n3 ? " " + n3 : "");
              }(t4, e3, o2) : t4.langFormat("accessibility.chartTypes.emptyChart", o2);
            }(t3, t3.types) : "";
          }
          getDataTableButtonText(t3) {
            let e3 = this.chart, i3 = e3.langFormat("accessibility.table.viewAsDataTableButtonText", { chart: e3, chartTitle: p(e3) });
            return '<button id="' + t3 + '">' + i3 + "</button>";
          }
          getSonifyButtonText(t3) {
            let e3 = this.chart;
            if (e3.options.sonification && false === e3.options.sonification.enabled)
              return "";
            let i3 = e3.langFormat("accessibility.sonification.playAsSoundButtonText", { chart: e3, chartTitle: p(e3) });
            return '<button id="' + t3 + '">' + i3 + "</button>";
          }
          getSubtitleText() {
            let t3 = this.chart.options.subtitle;
            return v(t3 && t3.text || "", this.chart.renderer.forExport);
          }
          getEndOfChartMarkerText() {
            let t3 = this.chart, e3 = t3.langFormat("accessibility.screenReaderSection.endOfChartMarker", { chart: t3 }), i3 = "highcharts-end-of-chart-marker-" + t3.index;
            return '<div id="' + i3 + '">' + e3 + "</div>";
          }
          onDataTableCreated(t3) {
            let e3 = this.chart;
            if (e3.options.accessibility.enabled) {
              this.viewDataTableButton && this.viewDataTableButton.setAttribute("aria-expanded", "true");
              let i3 = t3.tree.attributes || {};
              i3.tabindex = -1, i3.summary = e3.langFormat("accessibility.table.tableSummary", { chart: e3 }), t3.tree.attributes = i3;
            }
          }
          focusDataTable() {
            let t3 = this.dataTableDiv, e3 = t3 && t3.getElementsByTagName("table")[0];
            e3 && e3.focus && e3.focus();
          }
          initSonifyButton(t3) {
            let e3 = this.sonifyButton = x(t3), i3 = this.chart, s2 = (t4) => {
              e3 && (e3.setAttribute("aria-hidden", "true"), e3.setAttribute("aria-label", "")), t4.preventDefault(), t4.stopPropagation();
              let s3 = i3.langFormat("accessibility.sonification.playAsSoundClickAnnouncement", { chart: i3 });
              this.announcer.announce(s3), setTimeout(() => {
                e3 && (e3.removeAttribute("aria-hidden"), e3.removeAttribute("aria-label")), i3.sonify && i3.sonify();
              }, 1e3);
            };
            e3 && i3 && (e3.setAttribute("tabindex", -1), e3.onclick = function(t4) {
              let e4 = i3.options.accessibility && i3.options.accessibility.screenReaderSection.onPlayAsSoundClick;
              (e4 || s2).call(this, t4, i3);
            });
          }
          initDataTableButton(t3) {
            let e3 = this.viewDataTableButton = x(t3), i3 = this.chart, s2 = t3.replace("hc-linkto-", "");
            e3 && (w(e3, { tabindex: -1, "aria-expanded": !!x(s2) }), e3.onclick = i3.options.accessibility.screenReaderSection.onViewDataTableClick || function() {
              i3.viewData();
            });
          }
          getAxesDescription() {
            let t3 = this.chart, e3 = function(e4, i4) {
              let s3 = t3[e4];
              return s3.length > 1 || s3[0] && C(s3[0].options.accessibility && s3[0].options.accessibility.enabled, i4);
            }, i3 = !!t3.types && 0 > t3.types.indexOf("map") && 0 > t3.types.indexOf("treemap") && 0 > t3.types.indexOf("tilemap"), s2 = !!t3.hasCartesianSeries, n2 = e3("xAxis", !t3.angular && s2 && i3), o2 = e3("yAxis", s2 && i3), r2 = {};
            return n2 && (r2.xAxis = this.getAxisDescriptionText("xAxis")), o2 && (r2.yAxis = this.getAxisDescriptionText("yAxis")), r2;
          }
          getAxisDescriptionText(t3) {
            let e3 = this.chart, i3 = e3[t3];
            return e3.langFormat("accessibility.axis." + t3 + "Description" + (i3.length > 1 ? "Plural" : "Singular"), { chart: e3, names: i3.map(function(t4) {
              return d(t4);
            }), ranges: i3.map(function(t4) {
              return u(t4);
            }), numAxes: i3.length });
          }
          destroy() {
            this.announcer && this.announcer.destroy();
          }
        };
      }), i(e, "Accessibility/Components/MenuComponent.js", [e["Core/Chart/Chart.js"], e["Core/Globals.js"], e["Core/Utilities.js"], e["Accessibility/AccessibilityComponent.js"], e["Accessibility/KeyboardNavigationHandler.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Accessibility/Utils/HTMLUtilities.js"]], function(t2, e2, i2, s, n, o, r) {
        let { composed: a } = e2, { attr: l, pushUnique: h } = i2, { getChartTitle: c, unhideChartElementFromAT: d } = o, { getFakeMouseEvent: u } = r;
        function p(t3) {
          return t3.exportSVGElements && t3.exportSVGElements[0];
        }
        class g extends s {
          init() {
            let t3 = this.chart, e3 = this;
            this.addEvent(t3, "exportMenuShown", function() {
              e3.onMenuShown();
            }), this.addEvent(t3, "exportMenuHidden", function() {
              e3.onMenuHidden();
            }), this.createProxyGroup();
          }
          onMenuHidden() {
            let t3 = this.chart.exportContextMenu;
            t3 && t3.setAttribute("aria-hidden", "true"), this.setExportButtonExpandedState("false");
          }
          onMenuShown() {
            let t3 = this.chart, e3 = t3.exportContextMenu;
            e3 && (this.addAccessibleContextMenuAttribs(), d(t3, e3)), this.setExportButtonExpandedState("true");
          }
          setExportButtonExpandedState(t3) {
            this.exportButtonProxy && this.exportButtonProxy.innerElement.setAttribute("aria-expanded", t3);
          }
          onChartRender() {
            let t3 = this.chart, e3 = t3.focusElement, i3 = t3.accessibility;
            this.proxyProvider.clearGroup("chartMenu"), this.proxyMenuButton(), this.exportButtonProxy && e3 && e3 === t3.exportingGroup && (e3.focusBorder ? t3.setFocusToElement(e3, this.exportButtonProxy.innerElement) : i3 && i3.keyboardNavigation.tabindexContainer.focus());
          }
          proxyMenuButton() {
            let t3 = this.chart, e3 = this.proxyProvider, i3 = p(t3);
            (function(t4) {
              let e4 = t4.options.exporting, i4 = p(t4);
              return !!(e4 && false !== e4.enabled && e4.accessibility && e4.accessibility.enabled && i4 && i4.element);
            })(t3) && i3 && (this.exportButtonProxy = e3.addProxyElement("chartMenu", { click: i3 }, "button", { "aria-label": t3.langFormat("accessibility.exporting.menuButtonLabel", { chart: t3, chartTitle: c(t3) }), "aria-expanded": false, title: t3.options.lang.contextButtonTitle || null }));
          }
          createProxyGroup() {
            let t3 = this.chart;
            t3 && this.proxyProvider && this.proxyProvider.addGroup("chartMenu");
          }
          addAccessibleContextMenuAttribs() {
            let t3 = this.chart, e3 = t3.exportDivElements;
            if (e3 && e3.length) {
              e3.forEach((t4) => {
                t4 && ("LI" !== t4.tagName || t4.children && t4.children.length ? t4.setAttribute("aria-hidden", "true") : t4.setAttribute("tabindex", -1));
              });
              let i3 = e3[0] && e3[0].parentNode;
              i3 && l(i3, { "aria-hidden": void 0, "aria-label": t3.langFormat("accessibility.exporting.chartMenuLabel", { chart: t3 }), role: "list" });
            }
          }
          getKeyboardNavigation() {
            let t3 = this.keyCodes, e3 = this.chart, i3 = this;
            return new n(e3, { keyCodeMap: [[[t3.left, t3.up], function() {
              return i3.onKbdPrevious(this);
            }], [[t3.right, t3.down], function() {
              return i3.onKbdNext(this);
            }], [[t3.enter, t3.space], function() {
              return i3.onKbdClick(this);
            }]], validate: function() {
              return !!e3.exporting && false !== e3.options.exporting.enabled && false !== e3.options.exporting.accessibility.enabled;
            }, init: function() {
              let t4 = i3.exportButtonProxy, s2 = i3.chart.exportingGroup;
              t4 && s2 && e3.setFocusToElement(s2, t4.innerElement);
            }, terminate: function() {
              e3.hideExportMenu();
            } });
          }
          onKbdPrevious(t3) {
            let e3 = this.chart, i3 = e3.options.accessibility, s2 = t3.response, n2 = e3.highlightedExportItemIx || 0;
            for (; n2--; )
              if (e3.highlightExportItem(n2))
                return s2.success;
            return i3.keyboardNavigation.wrapAround ? (e3.highlightLastExportItem(), s2.success) : s2.prev;
          }
          onKbdNext(t3) {
            let e3 = this.chart, i3 = e3.options.accessibility, s2 = t3.response;
            for (let t4 = (e3.highlightedExportItemIx || 0) + 1; t4 < e3.exportDivElements.length; ++t4)
              if (e3.highlightExportItem(t4))
                return s2.success;
            return i3.keyboardNavigation.wrapAround ? (e3.highlightExportItem(0), s2.success) : s2.next;
          }
          onKbdClick(t3) {
            let e3 = this.chart, i3 = e3.exportDivElements[e3.highlightedExportItemIx], s2 = p(e3).element;
            return e3.openMenu ? this.fakeClickEvent(i3) : (this.fakeClickEvent(s2), e3.highlightExportItem(0)), t3.response.success;
          }
        }
        return function(e3) {
          function i3() {
            let t3 = p(this);
            if (t3) {
              let e4 = t3.element;
              e4.onclick && e4.onclick(u("click"));
            }
          }
          function s2() {
            let t3 = this.exportDivElements;
            t3 && this.exportContextMenu && this.openMenu && (t3.forEach((t4) => {
              t4 && "highcharts-menu-item" === t4.className && t4.onmouseout && t4.onmouseout(u("mouseout"));
            }), this.highlightedExportItemIx = 0, this.exportContextMenu.hideMenu(), this.container.focus());
          }
          function n2(t3) {
            let e4 = this.exportDivElements && this.exportDivElements[t3], i4 = this.exportDivElements && this.exportDivElements[this.highlightedExportItemIx];
            if (e4 && "LI" === e4.tagName && !(e4.children && e4.children.length)) {
              let s3 = !!(this.renderTo.getElementsByTagName("g")[0] || {}).focus;
              return e4.focus && s3 && e4.focus(), i4 && i4.onmouseout && i4.onmouseout(u("mouseout")), e4.onmouseover && e4.onmouseover(u("mouseover")), this.highlightedExportItemIx = t3, true;
            }
            return false;
          }
          function o2() {
            if (this.exportDivElements) {
              let t3 = this.exportDivElements.length;
              for (; t3--; )
                if (this.highlightExportItem(t3))
                  return true;
            }
            return false;
          }
          e3.compose = function e4(r2) {
            if (h(a, e4)) {
              let e5 = t2.prototype;
              e5.hideExportMenu = s2, e5.highlightExportItem = n2, e5.highlightLastExportItem = o2, e5.showExportMenu = i3;
            }
          };
        }(g || (g = {})), g;
      }), i(e, "Accessibility/KeyboardNavigation.js", [e["Core/Globals.js"], e["Accessibility/Components/MenuComponent.js"], e["Core/Utilities.js"], e["Accessibility/Utils/EventProvider.js"], e["Accessibility/Utils/HTMLUtilities.js"]], function(t2, e2, i2, s, n) {
        let { composed: o, doc: r, win: a } = t2, { addEvent: l, fireEvent: h, pushUnique: c } = i2, { getElement: d, simulatedEventTarget: u } = n;
        class p {
          constructor(t3, e3) {
            this.currentModuleIx = NaN, this.modules = [], this.init(t3, e3);
          }
          init(t3, e3) {
            let i3 = this.eventProvider = new s();
            this.chart = t3, this.components = e3, this.modules = [], this.currentModuleIx = 0, this.update(), i3.addEvent(this.tabindexContainer, "keydown", (t4) => this.onKeydown(t4)), i3.addEvent(this.tabindexContainer, "focus", (t4) => this.onFocus(t4)), ["mouseup", "touchend"].forEach((t4) => i3.addEvent(r, t4, (t5) => this.onMouseUp(t5))), ["mousedown", "touchstart"].forEach((e4) => i3.addEvent(t3.renderTo, e4, () => {
              this.isClickingChart = true;
            }));
          }
          update(t3) {
            let e3 = this.chart.options.accessibility, i3 = e3 && e3.keyboardNavigation, s2 = this.components;
            this.updateContainerTabindex(), i3 && i3.enabled && t3 && t3.length ? (this.modules = t3.reduce(function(t4, e4) {
              let i4 = s2[e4].getKeyboardNavigation();
              return t4.concat(i4);
            }, []), this.updateExitAnchor()) : (this.modules = [], this.currentModuleIx = 0, this.removeExitAnchor());
          }
          updateExitAnchor() {
            let t3 = `highcharts-end-of-chart-marker-${this.chart.index}`, e3 = d(t3);
            this.removeExitAnchor(), e3 ? (this.makeElementAnExitAnchor(e3), this.exitAnchor = e3) : this.createExitAnchor();
          }
          move(t3) {
            let e3 = this.modules && this.modules[this.currentModuleIx];
            e3 && e3.terminate && e3.terminate(t3), this.chart.focusElement && this.chart.focusElement.removeFocusBorder(), this.currentModuleIx += t3;
            let i3 = this.modules && this.modules[this.currentModuleIx];
            if (i3) {
              if (i3.validate && !i3.validate())
                return this.move(t3);
              if (i3.init)
                return i3.init(t3), true;
            }
            return this.currentModuleIx = 0, this.exiting = true, t3 > 0 ? this.exitAnchor && this.exitAnchor.focus() : this.tabindexContainer.focus(), false;
          }
          onFocus(t3) {
            let e3 = this.chart, i3 = t3.relatedTarget && e3.container.contains(t3.relatedTarget), s2 = e3.options.accessibility, n2 = s2 && s2.keyboardNavigation, o2 = n2 && n2.enabled;
            if (o2 && !this.exiting && !this.tabbingInBackwards && !this.isClickingChart && !i3) {
              let t4 = this.getFirstValidModuleIx();
              null !== t4 && (this.currentModuleIx = t4, this.modules[t4].init(1));
            }
            this.keyboardReset = false, this.exiting = false;
          }
          onMouseUp(t3) {
            if (delete this.isClickingChart, !this.keyboardReset && t3.relatedTarget !== u) {
              let e3 = this.chart;
              if (!t3.target || !e3.container.contains(t3.target)) {
                let t4 = this.modules && this.modules[this.currentModuleIx || 0];
                t4 && t4.terminate && t4.terminate(), this.currentModuleIx = 0;
              }
              e3.focusElement && (e3.focusElement.removeFocusBorder(), delete e3.focusElement), this.keyboardReset = true;
            }
          }
          onKeydown(t3) {
            let e3;
            let i3 = t3 || a.event, s2 = this.modules && this.modules.length && this.modules[this.currentModuleIx], n2 = i3.target;
            if ((!n2 || "INPUT" !== n2.nodeName || n2.classList.contains("highcharts-a11y-proxy-element")) && (this.keyboardReset = false, this.exiting = false, s2)) {
              let t4 = s2.run(i3);
              t4 === s2.response.success ? e3 = true : t4 === s2.response.prev ? e3 = this.move(-1) : t4 === s2.response.next && (e3 = this.move(1)), e3 && (i3.preventDefault(), i3.stopPropagation());
            }
          }
          updateContainerTabindex() {
            let t3;
            let e3 = this.chart.options.accessibility, i3 = e3 && e3.keyboardNavigation, s2 = !(i3 && false === i3.enabled), n2 = this.chart, o2 = n2.container;
            n2.renderTo.hasAttribute("tabindex") ? (o2.removeAttribute("tabindex"), t3 = n2.renderTo) : t3 = o2, this.tabindexContainer = t3;
            let r2 = t3.getAttribute("tabindex");
            s2 && !r2 ? t3.setAttribute("tabindex", "0") : s2 || n2.container.removeAttribute("tabindex");
          }
          createExitAnchor() {
            let t3 = this.chart, e3 = this.exitAnchor = r.createElement("div");
            t3.renderTo.appendChild(e3), this.makeElementAnExitAnchor(e3);
          }
          makeElementAnExitAnchor(t3) {
            let e3 = this.tabindexContainer.getAttribute("tabindex") || 0;
            t3.setAttribute("class", "highcharts-exit-anchor"), t3.setAttribute("tabindex", e3), t3.setAttribute("aria-hidden", false), this.addExitAnchorEventsToEl(t3);
          }
          removeExitAnchor() {
            this.exitAnchor && this.exitAnchor.parentNode && (this.exitAnchor.parentNode.removeChild(this.exitAnchor), delete this.exitAnchor);
          }
          addExitAnchorEventsToEl(t3) {
            let e3 = this.chart, i3 = this;
            this.eventProvider.addEvent(t3, "focus", function(t4) {
              let s2 = t4 || a.event, n2 = s2.relatedTarget && e3.container.contains(s2.relatedTarget), o2 = !(n2 || i3.exiting);
              if (e3.focusElement && delete e3.focusElement, o2) {
                if (i3.tabbingInBackwards = true, i3.tabindexContainer.focus(), delete i3.tabbingInBackwards, s2.preventDefault(), i3.modules && i3.modules.length) {
                  i3.currentModuleIx = i3.modules.length - 1;
                  let t5 = i3.modules[i3.currentModuleIx];
                  t5 && t5.validate && !t5.validate() ? i3.move(-1) : t5 && t5.init(-1);
                }
              } else
                i3.exiting = false;
            });
          }
          getFirstValidModuleIx() {
            let t3 = this.modules.length;
            for (let e3 = 0; e3 < t3; ++e3) {
              let t4 = this.modules[e3];
              if (!t4.validate || t4.validate())
                return e3;
            }
            return null;
          }
          destroy() {
            this.removeExitAnchor(), this.eventProvider.removeAddedEvents(), this.chart.container.removeAttribute("tabindex");
          }
        }
        return function(i3) {
          function s2() {
            let t3 = this;
            h(this, "dismissPopupContent", {}, function() {
              t3.tooltip && t3.tooltip.hide(0), t3.hideExportMenu();
            });
          }
          function n2(e3) {
            let i4 = e3.which || e3.keyCode;
            27 === i4 && t2.charts && t2.charts.forEach((t3) => {
              t3 && t3.dismissPopupContent && t3.dismissPopupContent();
            });
          }
          i3.compose = function t3(i4) {
            if (e2.compose(i4), c(o, t3)) {
              let t4 = i4.prototype;
              t4.dismissPopupContent = s2, l(r, "keydown", n2);
            }
            return i4;
          };
        }(p || (p = {})), p;
      }), i(e, "Accessibility/Components/LegendComponent.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Globals.js"], e["Core/Legend/Legend.js"], e["Core/Utilities.js"], e["Accessibility/AccessibilityComponent.js"], e["Accessibility/KeyboardNavigationHandler.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Accessibility/Utils/HTMLUtilities.js"]], function(t2, e2, i2, s, n, o, r, a) {
        let { animObject: l } = t2, { composed: h, doc: c } = e2, { addEvent: d, fireEvent: u, isNumber: p, pick: g, pushUnique: m, syncTimeout: b } = s, { getChartTitle: f } = r, { stripHTMLTagsFromString: x, addClass: y, removeClass: v } = a;
        function A(t3) {
          let e3 = t3.legend && t3.legend.allItems, i3 = t3.options.legend.accessibility || {}, s2 = t3.colorAxis && t3.colorAxis.some((t4) => !t4.dataClasses || !t4.dataClasses.length);
          return !!(e3 && e3.length && !s2 && false !== i3.enabled);
        }
        function w(t3, e3) {
          let i3 = e3.legendItem || {};
          for (let s2 of (e3.setState(t3 ? "hover" : "", true), ["group", "label", "symbol"])) {
            let e4 = i3[s2], n2 = e4 && e4.element || e4;
            n2 && u(n2, t3 ? "mouseover" : "mouseout");
          }
        }
        class C extends n {
          constructor() {
            super(...arguments), this.highlightedLegendItemIx = NaN, this.proxyGroup = null;
          }
          init() {
            let t3 = this;
            this.recreateProxies(), this.addEvent(i2, "afterScroll", function() {
              this.chart === t3.chart && (t3.proxyProvider.updateGroupProxyElementPositions("legend"), t3.updateLegendItemProxyVisibility(), t3.highlightedLegendItemIx > -1 && this.chart.highlightLegendItem(t3.highlightedLegendItemIx));
            }), this.addEvent(i2, "afterPositionItem", function(e3) {
              this.chart === t3.chart && this.chart.renderer && t3.updateProxyPositionForItem(e3.item);
            }), this.addEvent(i2, "afterRender", function() {
              this.chart === t3.chart && this.chart.renderer && t3.recreateProxies() && b(() => t3.proxyProvider.updateGroupProxyElementPositions("legend"), l(g(this.chart.renderer.globalAnimation, true)).duration);
            });
          }
          updateLegendItemProxyVisibility() {
            let t3;
            let e3 = this.chart, i3 = e3.legend, s2 = i3.allItems || [], n2 = i3.currentPage || 1, o2 = i3.clipHeight || 0;
            s2.forEach((s3) => {
              if (s3.a11yProxyElement) {
                let r2 = i3.pages && i3.pages.length, a2 = s3.a11yProxyElement.element, l2 = false;
                if (t3 = s3.legendItem || {}, r2) {
                  let e4 = t3.pageIx || 0, s4 = t3.y || 0, r3 = t3.label ? Math.round(t3.label.getBBox().height) : 0;
                  l2 = s4 + r3 - i3.pages[e4] > o2 || e4 !== n2 - 1;
                }
                l2 ? e3.styledMode ? y(a2, "highcharts-a11y-invisible") : a2.style.visibility = "hidden" : (v(a2, "highcharts-a11y-invisible"), a2.style.visibility = "");
              }
            });
          }
          onChartRender() {
            A(this.chart) || this.removeProxies();
          }
          highlightAdjacentLegendPage(t3) {
            let e3 = this.chart, i3 = e3.legend, s2 = i3.currentPage || 1, n2 = s2 + t3, o2 = i3.pages || [];
            if (n2 > 0 && n2 <= o2.length) {
              let t4 = 0;
              for (let s3 of i3.allItems)
                ((s3.legendItem || {}).pageIx || 0) + 1 === n2 && e3.highlightLegendItem(t4) && (this.highlightedLegendItemIx = t4), ++t4;
            }
          }
          updateProxyPositionForItem(t3) {
            t3.a11yProxyElement && t3.a11yProxyElement.refreshPosition();
          }
          recreateProxies() {
            let t3 = c.activeElement, e3 = this.proxyGroup, i3 = t3 && e3 && e3.contains(t3);
            return this.removeProxies(), !!A(this.chart) && (this.addLegendProxyGroup(), this.proxyLegendItems(), this.updateLegendItemProxyVisibility(), this.updateLegendTitle(), i3 && this.chart.highlightLegendItem(this.highlightedLegendItemIx), true);
          }
          removeProxies() {
            this.proxyProvider.removeGroup("legend");
          }
          updateLegendTitle() {
            let t3 = this.chart, e3 = x((t3.legend && t3.legend.options.title && t3.legend.options.title.text || "").replace(/<br ?\/?>/g, " "), t3.renderer.forExport), i3 = t3.langFormat("accessibility.legend.legendLabel" + (e3 ? "" : "NoTitle"), { chart: t3, legendTitle: e3, chartTitle: f(t3) });
            this.proxyProvider.updateGroupAttrs("legend", { "aria-label": i3 });
          }
          addLegendProxyGroup() {
            let t3 = this.chart.options.accessibility, e3 = "all" === t3.landmarkVerbosity ? "region" : null;
            this.proxyGroup = this.proxyProvider.addGroup("legend", "ul", { "aria-label": "_placeholder_", role: e3 });
          }
          proxyLegendItems() {
            let t3;
            let e3 = this, i3 = (this.chart.legend || {}).allItems || [];
            i3.forEach((i4) => {
              (t3 = i4.legendItem || {}).label && t3.label.element && e3.proxyLegendItem(i4);
            });
          }
          proxyLegendItem(t3) {
            let e3 = t3.legendItem || {};
            if (!e3.label || !e3.group)
              return;
            let i3 = this.chart.langFormat("accessibility.legend.legendItem", { chart: this.chart, itemName: x(t3.name, this.chart.renderer.forExport), item: t3 }), s2 = { tabindex: -1, "aria-pressed": t3.visible, "aria-label": i3 }, n2 = e3.group.div ? e3.label : e3.group;
            t3.a11yProxyElement = this.proxyProvider.addProxyElement("legend", { click: e3.label, visual: n2.element }, "button", s2);
          }
          getKeyboardNavigation() {
            let t3 = this.keyCodes, e3 = this, i3 = this.chart;
            return new o(i3, { keyCodeMap: [[[t3.left, t3.right, t3.up, t3.down], function(t4) {
              return e3.onKbdArrowKey(this, t4);
            }], [[t3.enter, t3.space], function() {
              return e3.onKbdClick(this);
            }], [[t3.pageDown, t3.pageUp], function(i4) {
              let s2 = i4 === t3.pageDown ? 1 : -1;
              return e3.highlightAdjacentLegendPage(s2), this.response.success;
            }]], validate: function() {
              return e3.shouldHaveLegendNavigation();
            }, init: function() {
              i3.highlightLegendItem(0), e3.highlightedLegendItemIx = 0;
            }, terminate: function() {
              e3.highlightedLegendItemIx = -1, i3.legend.allItems.forEach((t4) => w(false, t4));
            } });
          }
          onKbdArrowKey(t3, e3) {
            let { keyCodes: { left: i3, up: s2 }, highlightedLegendItemIx: n2, chart: o2 } = this, r2 = o2.legend.allItems.length, a2 = o2.options.accessibility.keyboardNavigation.wrapAround, l2 = e3 === i3 || e3 === s2 ? -1 : 1, h2 = o2.highlightLegendItem(n2 + l2);
            return h2 ? this.highlightedLegendItemIx += l2 : a2 && r2 > 1 && (this.highlightedLegendItemIx = l2 > 0 ? 0 : r2 - 1, o2.highlightLegendItem(this.highlightedLegendItemIx)), t3.response.success;
          }
          onKbdClick(t3) {
            let e3 = this.chart.legend.allItems[this.highlightedLegendItemIx];
            return e3 && e3.a11yProxyElement && e3.a11yProxyElement.click(), t3.response.success;
          }
          shouldHaveLegendNavigation() {
            if (!A(this.chart))
              return false;
            let t3 = this.chart, e3 = t3.options.legend || {}, i3 = e3.accessibility || {};
            return !!(t3.legend.display && i3.keyboardNavigation && i3.keyboardNavigation.enabled);
          }
          destroy() {
            this.removeProxies();
          }
        }
        return function(t3) {
          function e3(t4) {
            let e4 = this.legend.allItems, i4 = this.accessibility && this.accessibility.components.legend.highlightedLegendItemIx, s2 = e4[t4], n2 = (s2 == null ? void 0 : s2.legendItem) || {};
            if (s2) {
              p(i4) && e4[i4] && w(false, e4[i4]), function(t5, e5) {
                let i5 = (t5.allItems[e5].legendItem || {}).pageIx, s3 = t5.currentPage;
                void 0 !== i5 && i5 + 1 !== s3 && t5.scroll(1 + i5 - s3);
              }(this.legend, t4);
              let o2 = n2.label, r2 = s2.a11yProxyElement && s2.a11yProxyElement.element;
              return o2 && o2.element && r2 && this.setFocusToElement(o2, r2), w(true, s2), true;
            }
            return false;
          }
          function i3(t4) {
            let e4 = this.chart, i4 = e4.options.accessibility, s2 = t4.item;
            i4.enabled && s2 && s2.a11yProxyElement && s2.a11yProxyElement.innerElement.setAttribute("aria-pressed", t4.visible ? "true" : "false");
          }
          t3.compose = function t4(s2, n2) {
            if (m(h, t4)) {
              let t5 = s2.prototype;
              t5.highlightLegendItem = e3, d(n2, "afterColorizeItem", i3);
            }
          };
        }(C || (C = {})), C;
      }), i(e, "Core/Axis/NavigatorAxisComposition.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { composed: i2, isTouchDevice: s } = t2, { addEvent: n, correctFloat: o, defined: r, isNumber: a, pick: l, pushUnique: h } = e2;
        function c() {
          this.navigatorAxis || (this.navigatorAxis = new u(this));
        }
        function d(t3) {
          let e3 = this.chart, i3 = e3.options, n2 = i3.navigator, o2 = this.navigatorAxis, a2 = e3.zooming.pinchType, l2 = i3.rangeSelector, h2 = e3.zooming.type;
          if (this.isXAxis && (n2 && n2.enabled || l2 && l2.enabled)) {
            if ("y" === h2)
              t3.zoomed = false;
            else if ((!s && "xy" === h2 || s && "xy" === a2) && this.options.range) {
              let e4 = o2.previousZoom;
              r(t3.newMin) ? o2.previousZoom = [this.min, this.max] : e4 && (t3.newMin = e4[0], t3.newMax = e4[1], o2.previousZoom = void 0);
            }
          }
          void 0 !== t3.zoomed && t3.preventDefault();
        }
        class u {
          static compose(t3) {
            h(i2, this.compose) && (t3.keepProps.push("navigatorAxis"), n(t3, "init", c), n(t3, "zoom", d));
          }
          constructor(t3) {
            this.axis = t3;
          }
          destroy() {
            this.axis = void 0;
          }
          toFixedRange(t3, e3, i3, s2) {
            let n2 = this.axis, h2 = n2.chart, c2 = l(i3, n2.translate(t3, true, !n2.horiz)), d2 = l(s2, n2.translate(e3, true, !n2.horiz)), u2 = h2 && h2.fixedRange, p = (n2.pointRange || 0) / 2;
            return r(i3) || (c2 = o(c2 + p)), r(s2) || (d2 = o(d2 - p)), u2 && n2.dataMin && n2.dataMax && (d2 >= n2.dataMax && (c2 = o(n2.dataMax - u2)), c2 <= n2.dataMin && (d2 = o(n2.dataMin + u2))), a(c2) && a(d2) || (c2 = d2 = void 0), { min: c2, max: d2 };
          }
        }
        return u;
      }), i(e, "Stock/Navigator/NavigatorDefaults.js", [e["Core/Color/Color.js"], e["Core/Series/SeriesRegistry.js"]], function(t2, e2) {
        let { parse: i2 } = t2, { seriesTypes: s } = e2, n = { height: 40, margin: 25, maskInside: true, handles: { width: 7, height: 15, symbols: ["navigator-handle", "navigator-handle"], enabled: true, lineWidth: 1, backgroundColor: "#f2f2f2", borderColor: "#999999" }, maskFill: i2("#667aff").setOpacity(0.3).get(), outlineColor: "#999999", outlineWidth: 1, series: { type: void 0 === s.areaspline ? "line" : "areaspline", fillOpacity: 0.05, lineWidth: 1, compare: null, sonification: { enabled: false }, dataGrouping: { approximation: "average", enabled: true, groupPixelWidth: 2, firstAnchor: "firstPoint", anchor: "middle", lastAnchor: "lastPoint", units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]] }, dataLabels: { enabled: false, zIndex: 2 }, id: "highcharts-navigator-series", className: "highcharts-navigator-series", lineColor: null, marker: { enabled: false }, threshold: null }, xAxis: { overscroll: 0, className: "highcharts-navigator-xaxis", tickLength: 0, lineWidth: 0, gridLineColor: "#e6e6e6", gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", style: { color: "#000000", fontSize: "0.7em", opacity: 0.6, textOutline: "2px contrast" }, x: 3, y: -4 }, crosshair: false }, yAxis: { className: "highcharts-navigator-yaxis", gridLineWidth: 0, startOnTick: false, endOnTick: false, minPadding: 0.1, maxPadding: 0.1, labels: { enabled: false }, crosshair: false, title: { text: null }, tickLength: 0, tickWidth: 0 } };
        return n;
      }), i(e, "Stock/Navigator/NavigatorSymbols.js", [], function() {
        return { "navigator-handle": function(t2, e2, i2, s, n = {}) {
          let o = n.width ? n.width / 2 : i2, r = Math.round(o / 3) + 0.5;
          return [["M", -o - 1, 0.5], ["L", o, 0.5], ["L", o, (s = n.height || s) + 0.5], ["L", -o - 1, s + 0.5], ["L", -o - 1, 0.5], ["M", -r, 4], ["L", -r, s - 3], ["M", r - 1, 4], ["L", r - 1, s - 3]];
        } };
      }), i(e, "Stock/Navigator/NavigatorComposition.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Axis/NavigatorAxisComposition.js"], e["Stock/Navigator/NavigatorDefaults.js"], e["Stock/Navigator/NavigatorSymbols.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n, o, r) {
        let a;
        let { defaultOptions: l, setOptions: h } = t2, { composed: c, isTouchDevice: d } = e2, { getRendererType: u } = o, { addEvent: p, extend: g, merge: m, pick: b, pushUnique: f } = r;
        function x() {
          this.navigator && this.navigator.setBaseSeries(null, false);
        }
        function y() {
          var _a;
          let t3, e3, i3;
          let s2 = this.legend, n2 = this.navigator;
          if (n2) {
            t3 = s2 && s2.options, e3 = n2.xAxis, i3 = n2.yAxis;
            let { scrollbarHeight: o2, scrollButtonSize: r2 } = n2;
            this.inverted ? (n2.left = n2.opposite ? this.chartWidth - o2 - n2.height : this.spacing[3] + o2, n2.top = this.plotTop + r2) : (n2.left = b(e3.left, this.plotLeft + r2), n2.top = n2.navigatorOptions.top || this.chartHeight - n2.height - o2 - (((_a = this.scrollbar) == null ? void 0 : _a.options.margin) || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t3 && "bottom" === t3.verticalAlign && "proximate" !== t3.layout && t3.enabled && !t3.floating ? s2.legendHeight + b(t3.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e3 && i3 && (this.inverted ? e3.options.left = i3.options.left = n2.left : e3.options.top = i3.options.top = n2.top, e3.setAxisSize(), i3.setAxisSize());
          }
        }
        function v(t3) {
          !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new a(this), b(t3.redraw, true) && this.redraw(t3.animation));
        }
        function A() {
          let t3 = this.options;
          (t3.navigator.enabled || t3.scrollbar.enabled) && (this.scroller = this.navigator = new a(this));
        }
        function w() {
          let t3 = this.options, e3 = t3.navigator, i3 = t3.rangeSelector;
          if ((e3 && e3.enabled || i3 && i3.enabled) && (!d && "x" === this.zooming.type || d && "x" === this.zooming.pinchType))
            return false;
        }
        function C(t3) {
          let e3 = t3.navigator;
          if (e3 && t3.xAxis[0]) {
            let i3 = t3.xAxis[0].getExtremes();
            e3.render(i3.min, i3.max);
          }
        }
        function E(t3) {
          let e3 = t3.options.navigator || {}, i3 = t3.options.scrollbar || {};
          !this.navigator && !this.scroller && (e3.enabled || i3.enabled) && (m(true, this.options.navigator, e3), m(true, this.options.scrollbar, i3), delete t3.options.navigator, delete t3.options.scrollbar);
        }
        function T() {
          this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, false);
        }
        return { compose: function t3(e3, o2, r2, h2) {
          if (i2.compose(e3), a = r2, f(c, t3)) {
            let t4 = o2.prototype;
            t4.callbacks.push(C), p(o2, "afterAddSeries", x), p(o2, "afterSetChartSize", y), p(o2, "afterUpdate", v), p(o2, "beforeRender", A), p(o2, "beforeShowResetZoom", w), p(o2, "update", E), p(h2, "afterUpdate", T), g(u().prototype.symbols, n), g(l, { navigator: s });
          }
        } };
      }), i(e, "Core/Axis/ScrollbarAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var i2;
        let { composed: s } = t2, { addEvent: n, defined: o, pick: r, pushUnique: a } = e2;
        return function(t3) {
          let e3;
          function i3(t4) {
            let e4 = r(t4.options && t4.options.min, t4.min), i4 = r(t4.options && t4.options.max, t4.max);
            return { axisMin: e4, axisMax: i4, scrollMin: o(t4.dataMin) ? Math.min(e4, t4.min, t4.dataMin, r(t4.threshold, 1 / 0)) : e4, scrollMax: o(t4.dataMax) ? Math.max(i4, t4.max, t4.dataMax, r(t4.threshold, -1 / 0)) : i4 };
          }
          function l() {
            let t4 = this.scrollbar, e4 = t4 && !t4.options.opposite, i4 = this.horiz ? 2 : e4 ? 3 : 1;
            t4 && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[i4] += t4.size + (t4.options.margin || 0));
          }
          function h() {
            let t4 = this;
            t4.options && t4.options.scrollbar && t4.options.scrollbar.enabled && (t4.options.scrollbar.vertical = !t4.horiz, t4.options.startOnTick = t4.options.endOnTick = false, t4.scrollbar = new e3(t4.chart.renderer, t4.options.scrollbar, t4.chart), n(t4.scrollbar, "changed", function(e4) {
              let s2, n2;
              let { axisMin: r2, axisMax: a2, scrollMin: l2, scrollMax: h2 } = i3(t4), c2 = h2 - l2;
              if (o(r2) && o(a2)) {
                if (t4.horiz && !t4.reversed || !t4.horiz && t4.reversed ? (s2 = l2 + c2 * this.to, n2 = l2 + c2 * this.from) : (s2 = l2 + c2 * (1 - this.from), n2 = l2 + c2 * (1 - this.to)), this.shouldUpdateExtremes(e4.DOMType)) {
                  let i4 = "mousemove" !== e4.DOMType && "touchmove" !== e4.DOMType && void 0;
                  t4.setExtremes(n2, s2, true, i4, e4);
                } else
                  this.setRange(this.from, this.to);
              }
            }));
          }
          function c() {
            let t4, e4, s2;
            let { scrollMin: n2, scrollMax: r2 } = i3(this), a2 = this.scrollbar, l2 = this.axisTitleMargin + (this.titleOffset || 0), h2 = this.chart.scrollbarsOffsets, c2 = this.options.margin || 0;
            if (a2 && h2) {
              if (this.horiz)
                this.opposite || (h2[1] += l2), a2.position(this.left, this.top + this.height + 2 + h2[1] - (this.opposite ? c2 : 0), this.width, this.height), this.opposite || (h2[1] += c2), t4 = 1;
              else {
                let e5;
                this.opposite && (h2[0] += l2), e5 = a2.options.opposite ? this.left + this.width + 2 + h2[0] - (this.opposite ? 0 : c2) : this.opposite ? 0 : c2, a2.position(e5, this.top, this.width, this.height), this.opposite && (h2[0] += c2), t4 = 0;
              }
              h2[t4] += a2.size + (a2.options.margin || 0), isNaN(n2) || isNaN(r2) || !o(this.min) || !o(this.max) || this.min === this.max ? a2.setRange(0, 1) : (e4 = (this.min - n2) / (r2 - n2), s2 = (this.max - n2) / (r2 - n2), this.horiz && !this.reversed || !this.horiz && this.reversed ? a2.setRange(e4, s2) : a2.setRange(1 - s2, 1 - e4));
            }
          }
          t3.compose = function t4(i4, o2) {
            a(s, t4) && (e3 = o2, n(i4, "afterGetOffset", l), n(i4, "afterInit", h), n(i4, "afterRender", c));
          };
        }(i2 || (i2 = {})), i2;
      }), i(e, "Stock/Scrollbar/ScrollbarDefaults.js", [e["Core/Globals.js"]], function(t2) {
        let { isTouchDevice: e2 } = t2;
        return { height: 10, barBorderRadius: 5, buttonBorderRadius: 0, buttonsEnabled: false, liveRedraw: void 0, margin: void 0, minWidth: 6, opposite: true, step: 0.2, zIndex: 3, barBackgroundColor: "#cccccc", barBorderWidth: 0, barBorderColor: "#cccccc", buttonArrowColor: "#333333", buttonBackgroundColor: "#e6e6e6", buttonBorderColor: "#cccccc", buttonBorderWidth: 1, rifleColor: "none", trackBackgroundColor: "rgba(255, 255, 255, 0.001)", trackBorderColor: "#cccccc", trackBorderRadius: 5, trackBorderWidth: 1 };
      }), i(e, "Stock/Scrollbar/Scrollbar.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Axis/ScrollbarAxis.js"], e["Stock/Scrollbar/ScrollbarDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n) {
        let { defaultOptions: o } = t2, { addEvent: r, correctFloat: a, defined: l, destroyObjectProperties: h, fireEvent: c, merge: d, pick: u, removeEvent: p } = n;
        class g {
          static compose(t3) {
            i2.compose(t3, g);
          }
          static swapXY(t3, e3) {
            return e3 && t3.forEach((t4) => {
              let e4;
              let i3 = t4.length;
              for (let s2 = 0; s2 < i3; s2 += 2)
                "number" == typeof (e4 = t4[s2 + 1]) && (t4[s2 + 1] = t4[s2 + 2], t4[s2 + 2] = e4);
            }), t3;
          }
          constructor(t3, e3, i3) {
            this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t3, e3, i3);
          }
          addEvents() {
            let t3 = this.options.inverted ? [1, 0] : [0, 1], i3 = this.scrollbarButtons, s2 = this.scrollbarGroup.element, n2 = this.track.element, o2 = this.mouseDownHandler.bind(this), a2 = this.mouseMoveHandler.bind(this), l2 = this.mouseUpHandler.bind(this), h2 = [[i3[t3[0]].element, "click", this.buttonToMinClick.bind(this)], [i3[t3[1]].element, "click", this.buttonToMaxClick.bind(this)], [n2, "click", this.trackClick.bind(this)], [s2, "mousedown", o2], [s2.ownerDocument, "mousemove", a2], [s2.ownerDocument, "mouseup", l2]];
            e2.hasTouch && h2.push([s2, "touchstart", o2], [s2.ownerDocument, "touchmove", a2], [s2.ownerDocument, "touchend", l2]), h2.forEach(function(t4) {
              r.apply(null, t4);
            }), this._events = h2;
          }
          buttonToMaxClick(t3) {
            let e3 = (this.to - this.from) * u(this.options.step, 0.2);
            this.updatePosition(this.from + e3, this.to + e3), c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t3 });
          }
          buttonToMinClick(t3) {
            let e3 = a(this.to - this.from) * u(this.options.step, 0.2);
            this.updatePosition(a(this.from - e3), a(this.to - e3)), c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t3 });
          }
          cursorToScrollbarPosition(t3) {
            let e3 = this.options, i3 = e3.minWidth > this.calculatedWidth ? e3.minWidth : 0;
            return { chartX: (t3.chartX - this.x - this.xOffset) / (this.barWidth - i3), chartY: (t3.chartY - this.y - this.yOffset) / (this.barWidth - i3) };
          }
          destroy() {
            let t3 = this, e3 = t3.chart.scroller;
            t3.removeEvents(), ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function(e4) {
              t3[e4] && t3[e4].destroy && (t3[e4] = t3[e4].destroy());
            }), e3 && t3 === e3.scrollbar && (e3.scrollbar = null, h(e3.scrollbarButtons));
          }
          drawScrollbarButton(t3) {
            let e3 = this.renderer, i3 = this.scrollbarButtons, s2 = this.options, n2 = this.size, o2 = e3.g().add(this.group);
            if (i3.push(o2), s2.buttonsEnabled) {
              let r2 = e3.rect().addClass("highcharts-scrollbar-button").add(o2);
              this.chart.styledMode || r2.attr({ stroke: s2.buttonBorderColor, "stroke-width": s2.buttonBorderWidth, fill: s2.buttonBackgroundColor }), r2.attr(r2.crisp({ x: -0.5, y: -0.5, width: n2 + 1, height: n2 + 1, r: s2.buttonBorderRadius }, r2.strokeWidth()));
              let a2 = e3.path(g.swapXY([["M", n2 / 2 + (t3 ? -1 : 1), n2 / 2 - 3], ["L", n2 / 2 + (t3 ? -1 : 1), n2 / 2 + 3], ["L", n2 / 2 + (t3 ? 2 : -2), n2 / 2]], s2.vertical)).addClass("highcharts-scrollbar-arrow").add(i3[t3]);
              this.chart.styledMode || a2.attr({ fill: s2.buttonArrowColor });
            }
          }
          init(t3, e3, i3) {
            this.scrollbarButtons = [], this.renderer = t3, this.userOptions = e3, this.options = d(s, o.scrollbar, e3), this.options.margin = u(this.options.margin, 10), this.chart = i3, this.size = u(this.options.size, this.options.height), e3.enabled && (this.render(), this.addEvents());
          }
          mouseDownHandler(t3) {
            let e3 = this.chart.pointer.normalize(t3), i3 = this.cursorToScrollbarPosition(e3);
            this.chartX = i3.chartX, this.chartY = i3.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = true;
          }
          mouseMoveHandler(t3) {
            let e3;
            let i3 = this.chart.pointer.normalize(t3), s2 = this.options, n2 = s2.vertical ? "chartY" : "chartX", o2 = this.initPositions || [];
            this.grabbedCenter && (!t3.touches || 0 !== t3.touches[0][n2]) && (e3 = this.cursorToScrollbarPosition(i3)[n2] - this[n2], this.hasDragged = true, this.updatePosition(o2[0] + e3, o2[1] + e3), this.hasDragged && c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t3.type, DOMEvent: t3 }));
          }
          mouseUpHandler(t3) {
            this.hasDragged && c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t3.type, DOMEvent: t3 }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
          }
          position(t3, e3, i3, s2) {
            let n2 = this.options, { buttonsEnabled: o2, margin: r2 = 0, vertical: a2 } = n2, l2 = this.rendered ? "animate" : "attr", h2 = s2, c2 = 0;
            this.group.show(), this.x = t3, this.y = e3 + this.trackBorderWidth, this.width = i3, this.height = s2, this.xOffset = h2, this.yOffset = c2, a2 ? (this.width = this.yOffset = i3 = c2 = this.size, this.xOffset = h2 = 0, this.yOffset = c2 = o2 ? this.size : 0, this.barWidth = s2 - (o2 ? 2 * i3 : 0), this.x = t3 += r2) : (this.height = s2 = this.size, this.xOffset = h2 = o2 ? this.size : 0, this.barWidth = i3 - (o2 ? 2 * s2 : 0), this.y = this.y + r2), this.group[l2]({ translateX: t3, translateY: this.y }), this.track[l2]({ width: i3, height: s2 }), this.scrollbarButtons[1][l2]({ translateX: a2 ? 0 : i3 - h2, translateY: a2 ? s2 - c2 : 0 });
          }
          removeEvents() {
            this._events.forEach(function(t3) {
              p.apply(null, t3);
            }), this._events.length = 0;
          }
          render() {
            let t3 = this.renderer, e3 = this.options, i3 = this.size, s2 = this.chart.styledMode, n2 = t3.g("scrollbar").attr({ zIndex: e3.zIndex }).hide().add();
            this.group = n2, this.track = t3.rect().addClass("highcharts-scrollbar-track").attr({ r: e3.trackBorderRadius || 0, height: i3, width: i3 }).add(n2), s2 || this.track.attr({ fill: e3.trackBackgroundColor, stroke: e3.trackBorderColor, "stroke-width": e3.trackBorderWidth });
            let o2 = this.trackBorderWidth = this.track.strokeWidth();
            this.track.attr({ x: -o2 % 2 / 2, y: -o2 % 2 / 2 }), this.scrollbarGroup = t3.g().add(n2), this.scrollbar = t3.rect().addClass("highcharts-scrollbar-thumb").attr({ height: i3 - o2, width: i3 - o2, r: e3.barBorderRadius || 0 }).add(this.scrollbarGroup), this.scrollbarRifles = t3.path(g.swapXY([["M", -3, i3 / 4], ["L", -3, 2 * i3 / 3], ["M", 0, i3 / 4], ["L", 0, 2 * i3 / 3], ["M", 3, i3 / 4], ["L", 3, 2 * i3 / 3]], e3.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), s2 || (this.scrollbar.attr({ fill: e3.barBackgroundColor, stroke: e3.barBorderColor, "stroke-width": e3.barBorderWidth }), this.scrollbarRifles.attr({ stroke: e3.rifleColor, "stroke-width": 1 })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2), this.drawScrollbarButton(0), this.drawScrollbarButton(1);
          }
          setRange(t3, e3) {
            let i3, s2;
            let n2 = this.options, o2 = n2.vertical, r2 = n2.minWidth, h2 = this.barWidth, c2 = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
            if (!l(h2))
              return;
            let d2 = h2 * Math.min(e3, 1);
            i3 = Math.ceil(h2 * (t3 = Math.max(t3, 0))), this.calculatedWidth = s2 = a(d2 - i3), s2 < r2 && (i3 = (h2 - r2 + s2) * t3, s2 = r2);
            let u2 = Math.floor(i3 + this.xOffset + this.yOffset), p2 = s2 / 2 - 0.5;
            this.from = t3, this.to = e3, o2 ? (this.scrollbarGroup[c2]({ translateY: u2 }), this.scrollbar[c2]({ height: s2 }), this.scrollbarRifles[c2]({ translateY: p2 }), this.scrollbarTop = u2, this.scrollbarLeft = 0) : (this.scrollbarGroup[c2]({ translateX: u2 }), this.scrollbar[c2]({ width: s2 }), this.scrollbarRifles[c2]({ translateX: p2 }), this.scrollbarLeft = u2, this.scrollbarTop = 0), s2 <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), false === n2.showFull && (t3 <= 0 && e3 >= 1 ? this.group.hide() : this.group.show()), this.rendered = true;
          }
          shouldUpdateExtremes(t3) {
            return u(this.options.liveRedraw, e2.svg && !e2.isTouchDevice && !this.chart.boosted) || "mouseup" === t3 || "touchend" === t3 || !l(t3);
          }
          trackClick(t3) {
            let e3 = this.chart.pointer.normalize(t3), i3 = this.to - this.from, s2 = this.y + this.scrollbarTop, n2 = this.x + this.scrollbarLeft;
            this.options.vertical && e3.chartY > s2 || !this.options.vertical && e3.chartX > n2 ? this.updatePosition(this.from + i3, this.to + i3) : this.updatePosition(this.from - i3, this.to - i3), c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t3 });
          }
          update(t3) {
            this.destroy(), this.init(this.chart.renderer, d(true, this.options, t3), this.chart);
          }
          updatePosition(t3, e3) {
            e3 > 1 && (t3 = a(1 - a(e3 - t3)), e3 = 1), t3 < 0 && (e3 = a(e3 - t3), t3 = 0), this.from = t3, this.to = e3;
          }
        }
        return g.defaultOptions = s, o.scrollbar = d(true, g.defaultOptions, o.scrollbar), g;
      }), i(e, "Stock/Navigator/Navigator.js", [e["Core/Axis/Axis.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Axis/NavigatorAxisComposition.js"], e["Stock/Navigator/NavigatorComposition.js"], e["Stock/Scrollbar/Scrollbar.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n, o, r) {
        let { defaultOptions: a } = e2, { hasTouch: l, isTouchDevice: h } = i2, { addEvent: c, clamp: d, correctFloat: u, defined: p, destroyObjectProperties: g, erase: m, extend: b, find: f, fireEvent: x, isArray: y, isNumber: v, merge: A, pick: w, removeEvent: C, splat: E } = r;
        function T(t3, ...e3) {
          let i3 = [].filter.call(e3, v);
          if (i3.length)
            return Math[t3].apply(0, i3);
        }
        class M {
          static compose(t3, e3, i3) {
            n.compose(t3, e3, M, i3);
          }
          constructor(t3) {
            this.scrollbarHeight = 0, this.init(t3);
          }
          drawHandle(t3, e3, i3, s2) {
            let n2 = this.navigatorOptions.handles.height;
            this.handles[e3][s2](i3 ? { translateX: Math.round(this.left + this.height / 2), translateY: Math.round(this.top + parseInt(t3, 10) + 0.5 - n2) } : { translateX: Math.round(this.left + parseInt(t3, 10)), translateY: Math.round(this.top + this.height / 2 - n2 / 2 - 1) });
          }
          drawOutline(t3, e3, i3, s2) {
            let n2 = this.navigatorOptions.maskInside, o2 = this.outline.strokeWidth(), r2 = o2 / 2, a2 = o2 % 2 / 2, l2 = this.scrollButtonSize, h2 = this.size, c2 = this.top, d2 = this.height, u2 = c2 - r2, p2 = c2 + d2, g2 = this.left, m2, b2;
            i3 ? (m2 = c2 + e3 + a2, e3 = c2 + t3 + a2, b2 = [["M", g2 + d2, c2 - l2 - a2], ["L", g2 + d2, m2], ["L", g2, m2], ["M", g2, e3], ["L", g2 + d2, e3], ["L", g2 + d2, c2 + h2 + l2]], n2 && b2.push(["M", g2 + d2, m2 - r2], ["L", g2 + d2, e3 + r2])) : (g2 -= l2, t3 += g2 + l2 - a2, e3 += g2 + l2 - a2, b2 = [["M", g2, u2], ["L", t3, u2], ["L", t3, p2], ["M", e3, p2], ["L", e3, u2], ["L", g2 + h2 + 2 * l2, c2 + r2]], n2 && b2.push(["M", t3 - r2, u2], ["L", e3 + r2, u2])), this.outline[s2]({ d: b2 });
          }
          drawMasks(t3, e3, i3, s2) {
            let n2, o2, r2, a2;
            let l2 = this.left, h2 = this.top, c2 = this.height;
            i3 ? (r2 = [l2, l2, l2], a2 = [h2, h2 + t3, h2 + e3], o2 = [c2, c2, c2], n2 = [t3, e3 - t3, this.size - e3]) : (r2 = [l2, l2 + t3, l2 + e3], a2 = [h2, h2, h2], o2 = [t3, e3 - t3, this.size - e3], n2 = [c2, c2, c2]), this.shades.forEach((t4, e4) => {
              t4[s2]({ x: r2[e4], y: a2[e4], width: o2[e4], height: n2[e4] });
            });
          }
          renderElements() {
            let t3 = this, e3 = t3.navigatorOptions, i3 = e3.maskInside, s2 = t3.chart, n2 = s2.inverted, o2 = s2.renderer, r2 = { cursor: n2 ? "ns-resize" : "ew-resize" }, a2 = t3.navigatorGroup = o2.g("navigator").attr({ zIndex: 8, visibility: "hidden" }).add();
            if ([!i3, i3, !i3].forEach((i4, n3) => {
              let l2 = o2.rect().addClass("highcharts-navigator-mask" + (1 === n3 ? "-inside" : "-outside")).add(a2);
              s2.styledMode || (l2.attr({ fill: i4 ? e3.maskFill : "rgba(0,0,0,0)" }), 1 === n3 && l2.css(r2)), t3.shades[n3] = l2;
            }), t3.outline = o2.path().addClass("highcharts-navigator-outline").add(a2), s2.styledMode || t3.outline.attr({ "stroke-width": e3.outlineWidth, stroke: e3.outlineColor }), e3.handles && e3.handles.enabled) {
              let i4 = e3.handles, { height: n3, width: l2 } = i4;
              [0, 1].forEach((e4) => {
                t3.handles[e4] = o2.symbol(i4.symbols[e4], -l2 / 2 - 1, 0, l2, n3, i4), s2.inverted && t3.handles[e4].attr({ rotation: 90, rotationOriginX: Math.floor(-l2 / 2), rotationOriginY: (n3 + l2) / 2 }), t3.handles[e4].attr({ zIndex: 7 - e4 }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][e4]).add(a2), s2.styledMode || t3.handles[e4].attr({ fill: i4.backgroundColor, stroke: i4.borderColor, "stroke-width": i4.lineWidth }).css(r2);
              });
            }
          }
          update(t3) {
            (this.series || []).forEach((t4) => {
              t4.baseSeries && delete t4.baseSeries.navigatorSeries;
            }), this.destroy();
            let e3 = this.chart.options;
            A(true, e3.navigator, t3), this.init(this.chart);
          }
          render(t3, e3, i3, s2) {
            let n2 = this.chart, o2 = this.xAxis, r2 = o2.pointRange || 0, a2 = o2.navigatorAxis.fake ? n2.xAxis[0] : o2, l2 = this.navigatorEnabled, h2 = this.rendered, c2 = n2.inverted, g2 = n2.xAxis[0].minRange, m2 = n2.xAxis[0].options.maxRange, b2 = this.scrollButtonSize, f2, y2, A2, C2 = this.scrollbarHeight, E2, T2;
            if (this.hasDragged && !p(i3))
              return;
            if (t3 = u(t3 - r2 / 2), e3 = u(e3 + r2 / 2), !v(t3) || !v(e3)) {
              if (!h2)
                return;
              i3 = 0, s2 = w(o2.width, a2.width);
            }
            this.left = w(o2.left, n2.plotLeft + b2 + (c2 ? n2.plotWidth : 0));
            let M2 = this.size = E2 = w(o2.len, (c2 ? n2.plotHeight : n2.plotWidth) - 2 * b2);
            f2 = c2 ? C2 : E2 + 2 * b2, i3 = w(i3, o2.toPixels(t3, true)), s2 = w(s2, o2.toPixels(e3, true)), v(i3) && Math.abs(i3) !== 1 / 0 || (i3 = 0, s2 = f2);
            let S = o2.toValue(i3, true), k = o2.toValue(s2, true), P = Math.abs(u(k - S));
            P < g2 ? this.grabbedLeft ? i3 = o2.toPixels(k - g2 - r2, true) : this.grabbedRight && (s2 = o2.toPixels(S + g2 + r2, true)) : p(m2) && u(P - r2) > m2 && (this.grabbedLeft ? i3 = o2.toPixels(k - m2 - r2, true) : this.grabbedRight && (s2 = o2.toPixels(S + m2 + r2, true))), this.zoomedMax = d(Math.max(i3, s2), 0, M2), this.zoomedMin = d(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i3, s2), 0, M2), this.range = this.zoomedMax - this.zoomedMin, M2 = Math.round(this.zoomedMax);
            let B = Math.round(this.zoomedMin);
            l2 && (this.navigatorGroup.attr({ visibility: "inherit" }), T2 = h2 && !this.hasDragged ? "animate" : "attr", this.drawMasks(B, M2, c2, T2), this.drawOutline(B, M2, c2, T2), this.navigatorOptions.handles.enabled && (this.drawHandle(B, 0, c2, T2), this.drawHandle(M2, 1, c2, T2))), this.scrollbar && (c2 ? (A2 = this.top - b2, y2 = this.left - C2 + (l2 || !a2.opposite ? 0 : (a2.titleOffset || 0) + a2.axisTitleMargin), C2 = E2 + 2 * b2) : (A2 = this.top + (l2 ? this.height : -C2), y2 = this.left - b2), this.scrollbar.position(y2, A2, f2, C2), this.scrollbar.setRange(this.zoomedMin / (E2 || 1), this.zoomedMax / (E2 || 1))), this.rendered = true, x(this, "afterRender");
          }
          addMouseEvents() {
            let t3 = this, e3 = t3.chart, i3 = e3.container, s2 = [], n2, o2;
            t3.mouseMoveHandler = n2 = function(e4) {
              t3.onMouseMove(e4);
            }, t3.mouseUpHandler = o2 = function(e4) {
              t3.onMouseUp(e4);
            }, (s2 = t3.getPartsEvents("mousedown")).push(c(e3.renderTo, "mousemove", n2), c(i3.ownerDocument, "mouseup", o2)), l && (s2.push(c(e3.renderTo, "touchmove", n2), c(i3.ownerDocument, "touchend", o2)), s2.concat(t3.getPartsEvents("touchstart"))), t3.eventsToUnbind = s2, t3.series && t3.series[0] && s2.push(c(t3.series[0].xAxis, "foundExtremes", function() {
              e3.navigator.modifyNavigatorAxisExtremes();
            }));
          }
          getPartsEvents(t3) {
            let e3 = this, i3 = [];
            return ["shades", "handles"].forEach(function(s2) {
              e3[s2].forEach(function(n2, o2) {
                i3.push(c(n2.element, t3, function(t4) {
                  e3[s2 + "Mousedown"](t4, o2);
                }));
              });
            }), i3;
          }
          shadesMousedown(t3, e3) {
            t3 = this.chart.pointer.normalize(t3);
            let i3 = this.chart, s2 = this.xAxis, n2 = this.zoomedMin, o2 = this.size, r2 = this.range, a2 = this.left, l2 = t3.chartX, h2, c2, d2, u2;
            i3.inverted && (l2 = t3.chartY, a2 = this.top), 1 === e3 ? (this.grabbedCenter = l2, this.fixedWidth = r2, this.dragOffset = l2 - n2) : (u2 = l2 - a2 - r2 / 2, 0 === e3 ? u2 = Math.max(0, u2) : 2 === e3 && u2 + r2 >= o2 && (u2 = o2 - r2, this.reversedExtremes ? (u2 -= r2, c2 = this.getUnionExtremes().dataMin) : h2 = this.getUnionExtremes().dataMax), u2 !== n2 && (this.fixedWidth = r2, p((d2 = s2.navigatorAxis.toFixedRange(u2, u2 + r2, c2, h2)).min) && i3.xAxis[0].setExtremes(Math.min(d2.min, d2.max), Math.max(d2.min, d2.max), true, null, { trigger: "navigator" })));
          }
          handlesMousedown(t3, e3) {
            t3 = this.chart.pointer.normalize(t3);
            let i3 = this.chart, s2 = i3.xAxis[0], n2 = this.reversedExtremes;
            0 === e3 ? (this.grabbedLeft = true, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = n2 ? s2.min : s2.max) : (this.grabbedRight = true, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = n2 ? s2.max : s2.min), i3.fixedRange = null;
          }
          onMouseMove(t3) {
            let e3 = this, i3 = e3.chart, s2 = e3.navigatorSize, n2 = e3.range, o2 = e3.dragOffset, r2 = i3.inverted, a2 = e3.left, l2;
            (!t3.touches || 0 !== t3.touches[0].pageX) && (l2 = (t3 = i3.pointer.normalize(t3)).chartX, r2 && (a2 = e3.top, l2 = t3.chartY), e3.grabbedLeft ? (e3.hasDragged = true, e3.render(0, 0, l2 - a2, e3.otherHandlePos)) : e3.grabbedRight ? (e3.hasDragged = true, e3.render(0, 0, e3.otherHandlePos, l2 - a2)) : e3.grabbedCenter && (e3.hasDragged = true, l2 < o2 ? l2 = o2 : l2 > s2 + o2 - n2 && (l2 = s2 + o2 - n2), e3.render(0, 0, l2 - o2, l2 - o2 + n2)), e3.hasDragged && e3.scrollbar && w(e3.scrollbar.options.liveRedraw, !h && !this.chart.boosted) && (t3.DOMType = t3.type, setTimeout(function() {
              e3.onMouseUp(t3);
            }, 0)));
          }
          onMouseUp(t3) {
            let e3, i3, s2, n2, o2, r2;
            let a2 = this.chart, l2 = this.xAxis, h2 = this.scrollbar, c2 = t3.DOMEvent || t3, d2 = a2.inverted, u2 = this.rendered && !this.hasDragged ? "animate" : "attr";
            (this.hasDragged && (!h2 || !h2.hasDragged) || "scrollbar" === t3.trigger) && (s2 = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? n2 = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (o2 = this.fixedExtreme), this.zoomedMax === this.size && (o2 = this.reversedExtremes ? s2.dataMin : s2.dataMax), 0 === this.zoomedMin && (n2 = this.reversedExtremes ? s2.dataMax : s2.dataMin), p((r2 = l2.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, n2, o2)).min) && a2.xAxis[0].setExtremes(Math.min(r2.min, r2.max), Math.max(r2.min, r2.max), true, !this.hasDragged && null, { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: c2 })), "mousemove" !== t3.DOMType && "touchmove" !== t3.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && v(this.zoomedMin) && v(this.zoomedMax) && (i3 = Math.round(this.zoomedMin), e3 = Math.round(this.zoomedMax), this.shades && this.drawMasks(i3, e3, d2, u2), this.outline && this.drawOutline(i3, e3, d2, u2), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i3, 0, d2, u2), this.drawHandle(e3, 1, d2, u2)));
          }
          removeEvents() {
            this.eventsToUnbind && (this.eventsToUnbind.forEach(function(t3) {
              t3();
            }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();
          }
          removeBaseSeriesEvents() {
            let t3 = this.baseSeries || [];
            this.navigatorEnabled && t3[0] && (false !== this.navigatorOptions.adaptToUpdatedData && t3.forEach(function(t4) {
              C(t4, "updatedData", this.updatedDataHandler);
            }, this), t3[0].xAxis && C(t3[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
          }
          init(e3) {
            let i3 = e3.options, n2 = i3.navigator || {}, r2 = n2.enabled, a2 = i3.scrollbar || {}, l2 = a2.enabled, h2 = r2 && n2.height || 0, d2 = l2 && a2.height || 0, u2 = a2.buttonsEnabled && d2 || 0;
            this.handles = [], this.shades = [], this.chart = e3, this.setBaseSeries(), this.height = h2, this.scrollbarHeight = d2, this.scrollButtonSize = u2, this.scrollbarEnabled = l2, this.navigatorEnabled = r2, this.navigatorOptions = n2, this.scrollbarOptions = a2, this.opposite = w(n2.opposite, !!(!r2 && e3.inverted));
            let p2 = this, g2 = p2.baseSeries, m2 = e3.xAxis.length, b2 = e3.yAxis.length, f2 = g2 && g2[0] && g2[0].xAxis || e3.xAxis[0] || { options: {} };
            if (e3.isDirtyBox = true, p2.navigatorEnabled ? (p2.xAxis = new t2(e3, A({ breaks: f2.options.breaks, ordinal: f2.options.ordinal }, n2.xAxis, { id: "navigator-x-axis", yAxis: "navigator-y-axis", type: "datetime", index: m2, isInternal: true, offset: 0, keepOrdinalPadding: true, startOnTick: false, endOnTick: false, minPadding: 0, maxPadding: 0, zoomEnabled: false }, e3.inverted ? { offsets: [u2, 0, -u2, 0], width: h2 } : { offsets: [0, -u2, 0, u2], height: h2 }), "xAxis"), p2.yAxis = new t2(e3, A(n2.yAxis, { id: "navigator-y-axis", alignTicks: false, offset: 0, index: b2, isInternal: true, reversed: w(n2.yAxis && n2.yAxis.reversed, e3.yAxis[0] && e3.yAxis[0].reversed, false), zoomEnabled: false }, e3.inverted ? { width: h2 } : { height: h2 }), "yAxis"), g2 || n2.series.data ? p2.updateNavigatorSeries(false) : 0 === e3.series.length && (p2.unbindRedraw = c(e3, "beforeRedraw", function() {
              e3.series.length > 0 && !p2.series && (p2.setBaseSeries(), p2.unbindRedraw());
            })), p2.reversedExtremes = e3.inverted && !p2.xAxis.reversed || !e3.inverted && p2.xAxis.reversed, p2.renderElements(), p2.addMouseEvents()) : (p2.xAxis = { chart: e3, navigatorAxis: { fake: true }, translate: function(t3, i4) {
              let s2 = e3.xAxis[0], n3 = s2.getExtremes(), o2 = s2.len - 2 * u2, r3 = T("min", s2.options.min, n3.dataMin), a3 = T("max", s2.options.max, n3.dataMax) - r3;
              return i4 ? t3 * a3 / o2 + r3 : o2 * (t3 - r3) / a3;
            }, toPixels: function(t3) {
              return this.translate(t3);
            }, toValue: function(t3) {
              return this.translate(t3, true);
            } }, p2.xAxis.navigatorAxis.axis = p2.xAxis, p2.xAxis.navigatorAxis.toFixedRange = s.prototype.toFixedRange.bind(p2.xAxis.navigatorAxis)), e3.options.scrollbar.enabled) {
              let t3 = A(e3.options.scrollbar, { vertical: e3.inverted });
              !v(t3.margin) && p2.navigatorEnabled && (t3.margin = e3.inverted ? -3 : 3), e3.scrollbar = p2.scrollbar = new o(e3.renderer, t3, e3), c(p2.scrollbar, "changed", function(t4) {
                let e4 = p2.size, i4 = e4 * this.to, s2 = e4 * this.from;
                p2.hasDragged = p2.scrollbar.hasDragged, p2.render(0, 0, s2, i4), this.shouldUpdateExtremes(t4.DOMType) && setTimeout(function() {
                  p2.onMouseUp(t4);
                });
              });
            }
            p2.addBaseSeriesEvents(), p2.addChartEvents();
          }
          getUnionExtremes(t3) {
            let e3;
            let i3 = this.chart.xAxis[0], s2 = this.xAxis, n2 = s2.options, o2 = i3.options;
            return t3 && null === i3.dataMin || (e3 = { dataMin: w(n2 && n2.min, T("min", o2.min, i3.dataMin, s2.dataMin, s2.min)), dataMax: w(n2 && n2.max, T("max", o2.max, i3.dataMax, s2.dataMax, s2.max)) }), e3;
          }
          setBaseSeries(t3, e3) {
            let i3 = this.chart, s2 = this.baseSeries = [];
            t3 = t3 || i3.options && i3.options.navigator.baseSeries || (i3.series.length ? f(i3.series, (t4) => !t4.options.isInternal).index : 0), (i3.series || []).forEach((e4, i4) => {
              !e4.options.isInternal && (e4.options.showInNavigator || (i4 === t3 || e4.options.id === t3) && false !== e4.options.showInNavigator) && s2.push(e4);
            }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(true, e3);
          }
          updateNavigatorSeries(t3, e3) {
            let i3 = this, s2 = i3.chart, n2 = i3.baseSeries, o2 = { enableMouseTracking: false, index: null, linkedTo: null, group: "nav", padXAxis: false, xAxis: "navigator-x-axis", yAxis: "navigator-y-axis", showInLegend: false, stacking: void 0, isInternal: true, states: { inactive: { opacity: 1 } } }, r2 = i3.series = (i3.series || []).filter((t4) => {
              let e4 = t4.baseSeries;
              return !(0 > n2.indexOf(e4)) || (e4 && (C(e4, "updatedData", i3.updatedDataHandler), delete e4.navigatorSeries), t4.chart && t4.destroy(), false);
            }), l2, h2, c2 = i3.navigatorOptions.series, d2;
            n2 && n2.length && n2.forEach((t4) => {
              let u2 = t4.navigatorSeries, p2 = b({ color: t4.color, visible: t4.visible }, y(c2) ? a.navigator.series : c2);
              if (u2 && false === i3.navigatorOptions.adaptToUpdatedData)
                return;
              o2.name = "Navigator " + n2.length, d2 = (l2 = t4.options || {}).navigatorOptions || {}, p2.dataLabels = E(p2.dataLabels), (h2 = A(l2, o2, p2, d2)).pointRange = w(p2.pointRange, d2.pointRange, a.plotOptions[h2.type || "line"].pointRange);
              let g2 = d2.data || p2.data;
              i3.hasNavigatorData = i3.hasNavigatorData || !!g2, h2.data = g2 || l2.data && l2.data.slice(0), u2 && u2.options ? u2.update(h2, e3) : (t4.navigatorSeries = s2.initSeries(h2), t4.navigatorSeries.baseSeries = t4, r2.push(t4.navigatorSeries));
            }), (c2.data && !(n2 && n2.length) || y(c2)) && (i3.hasNavigatorData = false, (c2 = E(c2)).forEach((t4, e4) => {
              o2.name = "Navigator " + (r2.length + 1), (h2 = A(a.navigator.series, { color: s2.series[e4] && !s2.series[e4].options.isInternal && s2.series[e4].color || s2.options.colors[e4] || s2.options.colors[0] }, o2, t4)).data = t4.data, h2.data && (i3.hasNavigatorData = true, r2.push(s2.initSeries(h2)));
            })), t3 && this.addBaseSeriesEvents();
          }
          addBaseSeriesEvents() {
            let t3 = this, e3 = t3.baseSeries || [];
            e3[0] && e3[0].xAxis && e3[0].eventsToUnbind.push(c(e3[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)), e3.forEach((e4) => {
              e4.eventsToUnbind.push(c(e4, "show", function() {
                this.navigatorSeries && this.navigatorSeries.setVisible(true, false);
              })), e4.eventsToUnbind.push(c(e4, "hide", function() {
                this.navigatorSeries && this.navigatorSeries.setVisible(false, false);
              })), false !== this.navigatorOptions.adaptToUpdatedData && e4.xAxis && e4.eventsToUnbind.push(c(e4, "updatedData", this.updatedDataHandler)), e4.eventsToUnbind.push(c(e4, "remove", function() {
                this.navigatorSeries && (m(t3.series, this.navigatorSeries), p(this.navigatorSeries.options) && this.navigatorSeries.remove(false), delete this.navigatorSeries);
              }));
            });
          }
          getBaseSeriesMin(t3) {
            return this.baseSeries.reduce(function(t4, e3) {
              return Math.min(t4, e3.xData && e3.xData.length ? e3.xData[0] : t4);
            }, t3);
          }
          modifyNavigatorAxisExtremes() {
            let t3 = this.xAxis;
            if (void 0 !== t3.getExtremes) {
              let e3 = this.getUnionExtremes(true);
              e3 && (e3.dataMin !== t3.min || e3.dataMax !== t3.max) && (t3.min = e3.dataMin, t3.max = e3.dataMax);
            }
          }
          modifyBaseAxisExtremes() {
            let t3, e3;
            let i3 = this.chart.navigator, s2 = this.getExtremes(), n2 = s2.min, o2 = s2.max, r2 = s2.dataMin, a2 = s2.dataMax, l2 = o2 - n2, h2 = i3.stickToMin, c2 = i3.stickToMax, d2 = w(this.options.overscroll, 0), u2 = i3.series && i3.series[0], p2 = !!this.setExtremes, g2 = this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger;
            !g2 && (h2 && (t3 = (e3 = r2) + l2), c2 && (t3 = a2 + d2, h2 || (e3 = Math.max(r2, t3 - l2, i3.getBaseSeriesMin(u2 && u2.xData ? u2.xData[0] : -Number.MAX_VALUE)))), p2 && (h2 || c2) && v(e3) && (this.min = this.userMin = e3, this.max = this.userMax = t3)), i3.stickToMin = i3.stickToMax = null;
          }
          updatedDataHandler() {
            let t3 = this.chart.navigator, e3 = this.navigatorSeries, i3 = t3.reversedExtremes ? 0 === Math.round(t3.zoomedMin) : Math.round(t3.zoomedMax) >= Math.round(t3.size);
            t3.stickToMax = w(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i3), t3.stickToMin = t3.shouldStickToMin(this, t3), e3 && !t3.hasNavigatorData && (e3.options.pointStart = this.xData[0], e3.setData(this.options.data, false, null, false));
          }
          shouldStickToMin(t3, e3) {
            let i3 = e3.getBaseSeriesMin(t3.xData[0]), s2 = t3.xAxis, n2 = s2.max, o2 = s2.min, r2 = s2.options.range;
            return !!(v(n2) && v(o2)) && (r2 && n2 - i3 > 0 ? n2 - i3 < r2 : o2 <= i3);
          }
          addChartEvents() {
            this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(c(this.chart, "redraw", function() {
              let t3 = this.navigator, e3 = t3 && (t3.baseSeries && t3.baseSeries[0] && t3.baseSeries[0].xAxis || this.xAxis[0]);
              e3 && t3.render(e3.min, e3.max);
            }), c(this.chart, "getMargins", function() {
              let t3 = this.navigator, e3 = t3.opposite ? "plotTop" : "marginBottom";
              this.inverted && (e3 = t3.opposite ? "marginRight" : "plotLeft"), this[e3] = (this[e3] || 0) + (t3.navigatorEnabled || !this.inverted ? t3.height + t3.scrollbarHeight : 0) + t3.navigatorOptions.margin;
            }));
          }
          destroy() {
            this.removeEvents(), this.xAxis && (m(this.chart.xAxis, this.xAxis), m(this.chart.axes, this.xAxis)), this.yAxis && (m(this.chart.yAxis, this.yAxis), m(this.chart.axes, this.yAxis)), (this.series || []).forEach((t3) => {
              t3.destroy && t3.destroy();
            }), ["series", "xAxis", "yAxis", "shades", "outline", "scrollbarTrack", "scrollbarRifles", "scrollbarGroup", "scrollbar", "navigatorGroup", "rendered"].forEach((t3) => {
              this[t3] && this[t3].destroy && this[t3].destroy(), this[t3] = null;
            }), [this.handles].forEach((t3) => {
              g(t3);
            });
          }
        }
        return M;
      }), i(e, "Accessibility/Components/NavigatorComponent.js", [e["Accessibility/AccessibilityComponent.js"], e["Accessibility/Utils/Announcer.js"], e["Accessibility/KeyboardNavigationHandler.js"], e["Stock/Navigator/Navigator.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/Templating.js"], e["Core/Utilities.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Accessibility/Utils/ChartUtilities.js"]], function(t2, e2, i2, s, n, o, r, a, l) {
        let { animObject: h } = n, { format: c } = o, { clamp: d, pick: u, syncTimeout: p } = r, { getFakeMouseEvent: g } = a, { getAxisRangeDescription: m, fireEventOnWrappedOrUnwrappedElement: b } = l;
        return class extends t2 {
          init() {
            let t3 = this.chart, i3 = this;
            this.announcer = new e2(t3, "polite"), this.addEvent(s, "afterRender", function() {
              this.chart === i3.chart && this.chart.renderer && p(() => {
                i3.proxyProvider.updateGroupProxyElementPositions("navigator"), i3.updateHandleValues();
              }, h(u(this.chart.renderer.globalAnimation, true)).duration);
            });
          }
          onChartUpdate() {
            var _a, _b, _c;
            let t3 = this.chart, e3 = t3.options;
            if ((_a = e3.navigator.accessibility) == null ? void 0 : _a.enabled) {
              let i3 = e3.accessibility.landmarkVerbosity, s2 = (_b = e3.lang.accessibility) == null ? void 0 : _b.navigator.groupLabel;
              this.proxyProvider.removeGroup("navigator"), this.proxyProvider.addGroup("navigator", "div", { role: "all" === i3 ? "region" : "group", "aria-label": c(s2, { chart: t3 }, t3) });
              let n2 = (_c = e3.lang.accessibility) == null ? void 0 : _c.navigator.handleLabel;
              [0, 1].forEach((e4) => {
                let i4 = this.getHandleByIx(e4);
                if (i4) {
                  let s3 = this.proxyProvider.addProxyElement("navigator", { click: i4 }, "input", { type: "range", "aria-label": c(n2, { handleIx: e4, chart: t3 }, t3) });
                  this[e4 ? "maxHandleProxy" : "minHandleProxy"] = s3.innerElement, s3.innerElement.style.pointerEvents = "none", s3.innerElement.oninput = () => this.updateNavigator();
                }
              }), this.updateHandleValues();
            } else
              this.proxyProvider.removeGroup("navigator");
          }
          getNavigatorHandleNavigation(t3) {
            let e3 = this, s2 = this.chart, n2 = t3 ? this.maxHandleProxy : this.minHandleProxy, o2 = this.keyCodes;
            return new i2(s2, { keyCodeMap: [[[o2.left, o2.right, o2.up, o2.down], function(i3) {
              if (n2) {
                let r2 = i3 === o2.left || i3 === o2.up ? -1 : 1;
                n2.value = "" + d(parseFloat(n2.value) + r2, 0, 100), e3.updateNavigator(() => {
                  let i4 = e3.getHandleByIx(t3);
                  i4 && s2.setFocusToElement(i4, n2);
                });
              }
              return this.response.success;
            }]], init: () => {
              s2.setFocusToElement(this.getHandleByIx(t3), n2);
            }, validate: () => {
              var _a;
              return !!(this.getHandleByIx(t3) && n2 && ((_a = s2.options.navigator.accessibility) == null ? void 0 : _a.enabled));
            } });
          }
          getKeyboardNavigation() {
            return [this.getNavigatorHandleNavigation(0), this.getNavigatorHandleNavigation(1)];
          }
          destroy() {
            this.updateNavigatorThrottleTimer && clearTimeout(this.updateNavigatorThrottleTimer), this.proxyProvider.removeGroup("navigator"), this.announcer && this.announcer.destroy();
          }
          updateHandleValues() {
            let t3 = this.chart.navigator;
            if (t3 && this.minHandleProxy && this.maxHandleProxy) {
              let e3 = t3.size;
              this.minHandleProxy.value = "" + Math.round(t3.zoomedMin / e3 * 100), this.maxHandleProxy.value = "" + Math.round(t3.zoomedMax / e3 * 100);
            }
          }
          getHandleByIx(t3) {
            let e3 = this.chart.navigator;
            return e3 && e3.handles && e3.handles[t3];
          }
          updateNavigator(t3) {
            this.updateNavigatorThrottleTimer && clearTimeout(this.updateNavigatorThrottleTimer), this.updateNavigatorThrottleTimer = setTimeout(((t4) => {
              var _a;
              let e3 = this.chart, i3 = e3.navigator;
              if (i3 && this.minHandleProxy && this.maxHandleProxy) {
                let s2 = e3.pointer.getChartPosition(), n2 = parseFloat(this.minHandleProxy.value) / 100 * i3.size, o2 = parseFloat(this.maxHandleProxy.value) / 100 * i3.size;
                [[0, "mousedown", i3.zoomedMin], [0, "mousemove", n2], [0, "mouseup", n2], [1, "mousedown", i3.zoomedMax], [1, "mousemove", o2], [1, "mouseup", o2]].forEach(([t5, e4, n3]) => {
                  var _a2;
                  let o3 = (_a2 = this.getHandleByIx(t5)) == null ? void 0 : _a2.element;
                  o3 && b(o3, g(e4, { x: s2.left + i3.left + n3, y: s2.top + i3.top }, o3));
                }), t4 && t4();
                let r2 = (_a = e3.options.lang.accessibility) == null ? void 0 : _a.navigator.changeAnnouncement, a2 = m(e3.xAxis[0]);
                this.announcer.announce(c(r2, { axisRangeDescription: a2, chart: e3 }, e3));
              }
            }).bind(this, t3), 20);
          }
        };
      }), i(e, "Accessibility/Components/SeriesComponent/SeriesDescriber.js", [e["Accessibility/Components/AnnotationsA11y.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Core/Templating.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n) {
        let { getPointAnnotationTexts: o } = t2, { getAxisDescription: r, getSeriesFirstPointElement: a, getSeriesA11yElement: l, unhideChartElementFromAT: h } = e2, { format: c, numberFormat: d } = i2, { reverseChildNodes: u, stripHTMLTagsFromString: p } = s, { find: g, isNumber: m, isString: b, pick: f, defined: x } = n;
        function y(t3) {
          let e3 = t3.chart.options.accessibility, i3 = e3.series.pointDescriptionEnabledThreshold;
          return !!(false !== i3 && t3.points && t3.points.length >= +i3);
        }
        function v(t3, e3) {
          let i3 = t3.series, s2 = i3.chart, n2 = s2.options.accessibility.point || {}, o2 = i3.options.accessibility && i3.options.accessibility.point || {}, r2 = i3.tooltipOptions || {}, a2 = s2.options.lang;
          return m(e3) ? d(e3, o2.valueDecimals || n2.valueDecimals || r2.valueDecimals || -1, a2.decimalPoint, a2.accessibility.thousandsSep || a2.thousandsSep) : e3;
        }
        function A(t3, e3) {
          let i3 = t3[e3];
          return t3.chart.langFormat("accessibility.series." + e3 + "Description", { name: r(i3), series: t3 });
        }
        function w(t3) {
          let e3 = t3.series, i3 = e3.chart.series.length > 1 || e3.options.name, s2 = function(t4) {
            let e4 = t4.series, i4 = e4.chart, s3 = e4.options.accessibility, n3 = s3 && s3.point && s3.point.valueDescriptionFormat, o2 = n3 || i4.options.accessibility.point.valueDescriptionFormat, r3 = f(e4.xAxis && e4.xAxis.options.accessibility && e4.xAxis.options.accessibility.enabled, !i4.angular && "flowmap" !== e4.type), a3 = r3 ? function(t5) {
              let e5 = function(t6) {
                let e6 = t6.series, i6 = e6.chart, s5 = e6.options.accessibility && e6.options.accessibility.point || {}, n5 = i6.options.accessibility.point || {}, o4 = e6.xAxis && e6.xAxis.dateTime;
                if (o4) {
                  let e7 = o4.getXDateFormat(t6.x || 0, i6.options.tooltip.dateTimeLabelFormats), r4 = s5.dateFormatter && s5.dateFormatter(t6) || n5.dateFormatter && n5.dateFormatter(t6) || s5.dateFormat || n5.dateFormat || e7;
                  return i6.time.dateFormat(r4, t6.x || 0, void 0);
                }
              }(t5), i5 = t5.series.xAxis || {}, s4 = i5.categories && x(t5.category) && ("" + t5.category).replace("<br/>", " "), n4 = x(t5.id) && 0 > ("" + t5.id).indexOf("highcharts-"), o3 = "x, " + t5.x;
              return t5.name || e5 || s4 || (n4 ? t5.id : o3);
            }(t4) : "", l2 = { point: t4, index: x(t4.index) ? t4.index + 1 : "", xDescription: a3, value: function(t5) {
              let e5 = t5.series, i5 = e5.chart.options.accessibility.point || {}, s4 = e5.chart.options.accessibility && e5.chart.options.accessibility.point || {}, n4 = e5.tooltipOptions || {}, o3 = s4.valuePrefix || i5.valuePrefix || n4.valuePrefix || "", r4 = s4.valueSuffix || i5.valueSuffix || n4.valueSuffix || "", a4 = void 0 !== t5.value ? "value" : "y", l3 = v(t5, t5[a4]);
              return t5.isNull ? e5.chart.langFormat("accessibility.series.nullPointValue", { point: t5 }) : e5.pointArrayMap ? function(t6, e6, i6) {
                let s5 = e6 || "", n5 = i6 || "", o4 = function(e7) {
                  let i7 = v(t6, f(t6[e7], t6.options[e7]));
                  return void 0 !== i7 ? e7 + ": " + s5 + i7 + n5 : i7;
                }, r5 = t6.series.pointArrayMap;
                return r5.reduce(function(t7, e7) {
                  let i7 = o4(e7);
                  return i7 ? t7 + (t7.length ? ", " : "") + i7 : t7;
                }, "");
              }(t5, o3, r4) : o3 + l3 + r4;
            }(t4), separator: r3 ? ", " : "" };
            return c(o2, l2, i4);
          }(t3), n2 = t3.options && t3.options.accessibility && t3.options.accessibility.description, r2 = i3 ? " " + e3.name + "." : "", a2 = function(t4) {
            let e4 = t4.series.chart, i4 = o(t4);
            return i4.length ? e4.langFormat("accessibility.series.pointAnnotationsDescription", { point: t4, annotations: i4 }) : "";
          }(t3);
          return t3.accessibility = t3.accessibility || {}, t3.accessibility.valueDescription = s2, s2 + (n2 ? " " + n2 : "") + r2 + (a2 ? " " + a2 : "");
        }
        function C(t3) {
          let e3 = t3.chart, i3 = e3.types || [], s2 = function(t4) {
            let e4 = t4.options.accessibility || {}, i4 = e4.description;
            return i4 && t4.chart.langFormat("accessibility.series.description", { description: i4, series: t4 }) || "";
          }(t3), n2 = function(i4) {
            return e3[i4] && e3[i4].length > 1 && t3[i4];
          }, o2 = t3.index + 1, r2 = A(t3, "xAxis"), a2 = A(t3, "yAxis"), l2 = { seriesNumber: o2, series: t3, chart: e3 }, h2 = i3.length > 1 ? "Combination" : "", d2 = e3.langFormat("accessibility.series.summary." + t3.type + h2, l2) || e3.langFormat("accessibility.series.summary.default" + h2, l2), u2 = (n2("yAxis") ? " " + a2 + "." : "") + (n2("xAxis") ? " " + r2 + "." : ""), p2 = f(t3.options.accessibility && t3.options.accessibility.descriptionFormat, e3.options.accessibility.series.descriptionFormat, "");
          return c(p2, { seriesDescription: d2, authorDescription: s2 ? " " + s2 : "", axisDescription: u2, series: t3, chart: e3, seriesNumber: o2 }, void 0);
        }
        return { defaultPointDescriptionFormatter: w, defaultSeriesDescriptionFormatter: C, describeSeries: function(t3) {
          let e3 = t3.chart, i3 = a(t3), s2 = l(t3), n2 = e3.is3d && e3.is3d();
          s2 && (s2.lastChild !== i3 || n2 || u(s2), function(t4) {
            let e4 = function(t5) {
              let e5 = t5.options.accessibility || {};
              return !y(t5) && !e5.exposeAsGroupOnly;
            }(t4), i4 = function(t5) {
              let e5 = t5.chart.options.accessibility, i5 = e5.keyboardNavigation.seriesNavigation;
              return !!(t5.points && (t5.points.length < +i5.pointNavigationEnabledThreshold || false === i5.pointNavigationEnabledThreshold));
            }(t4), s3 = t4.chart.options.accessibility.point.describeNull;
            (e4 || i4) && t4.points.forEach((i5) => {
              let n3 = i5.graphic && i5.graphic.element || function(t5) {
                let e5 = t5.series, i6 = e5 && e5.chart, s4 = e5 && e5.is("sunburst"), n4 = t5.isNull, o3 = i6 && i6.options.accessibility.point.describeNull;
                return n4 && !s4 && o3;
              }(i5) && function(t5) {
                let e5 = t5.series, i6 = function(t6) {
                  let e6 = t6.index;
                  return t6.series && t6.series.data && x(e6) && g(t6.series.data, function(t7) {
                    return !!(t7 && void 0 !== t7.index && t7.index > e6 && t7.graphic && t7.graphic.element);
                  }) || null;
                }(t5), s4 = i6 && i6.graphic, n4 = s4 ? s4.parentGroup : e5.graph || e5.group, o3 = i6 ? { x: f(t5.plotX, i6.plotX, 0), y: f(t5.plotY, i6.plotY, 0) } : { x: f(t5.plotX, 0), y: f(t5.plotY, 0) }, r2 = function(t6, e6) {
                  let i7 = t6.series.chart.renderer, s5 = i7.rect(e6.x, e6.y, 1, 1);
                  return s5.attr({ class: "highcharts-a11y-mock-point", fill: "none", opacity: 0, "fill-opacity": 0, "stroke-opacity": 0 }), s5;
                }(t5, o3);
                if (n4 && n4.element)
                  return t5.graphic = r2, t5.hasMockGraphic = true, r2.add(n4), n4.element.insertBefore(r2.element, s4 ? s4.element : null), r2.element;
              }(i5), o2 = i5.options && i5.options.accessibility && false === i5.options.accessibility.enabled;
              if (n3) {
                if (i5.isNull && !s3) {
                  n3.setAttribute("aria-hidden", true);
                  return;
                }
                n3.setAttribute("tabindex", "-1"), t4.chart.styledMode || (n3.style.outline = "none"), e4 && !o2 ? function(t5, e5) {
                  var _a, _b, _c;
                  let i6 = t5.series, s4 = ((_a = i6.options.accessibility) == null ? void 0 : _a.point) || {}, n4 = i6.chart.options.accessibility.point || {}, o3 = p(b(s4.descriptionFormat) && c(s4.descriptionFormat, t5, i6.chart) || ((_b = s4.descriptionFormatter) == null ? void 0 : _b.call(s4, t5)) || b(n4.descriptionFormat) && c(n4.descriptionFormat, t5, i6.chart) || ((_c = n4.descriptionFormatter) == null ? void 0 : _c.call(n4, t5)) || w(t5), i6.chart.renderer.forExport);
                  e5.setAttribute("role", "img"), e5.setAttribute("aria-label", o3);
                }(i5, n3) : n3.setAttribute("aria-hidden", true);
              }
            });
          }(t3), h(e3, s2), function(t4) {
            let e4 = t4.chart, i4 = e4.options.chart, s3 = i4.options3d && i4.options3d.enabled, n3 = e4.series.length > 1, o2 = e4.options.accessibility.series.describeSingleSeries, r2 = (t4.options.accessibility || {}).exposeAsGroupOnly;
            return !(s3 && n3) && (n3 || o2 || r2 || y(t4));
          }(t3) ? function(t4, e4) {
            let i4 = t4.options.accessibility || {}, s3 = t4.chart.options.accessibility, n3 = s3.landmarkVerbosity;
            i4.exposeAsGroupOnly ? e4.setAttribute("role", "img") : "all" === n3 ? e4.setAttribute("role", "region") : e4.setAttribute("role", "group"), e4.setAttribute("tabindex", "-1"), t4.chart.styledMode || (e4.style.outline = "none"), e4.setAttribute("aria-label", p(s3.series.descriptionFormatter && s3.series.descriptionFormatter(t4) || C(t4), t4.chart.renderer.forExport));
          }(t3, s2) : s2.removeAttribute("aria-label"));
        } };
      }), i(e, "Accessibility/Components/SeriesComponent/NewDataAnnouncer.js", [e["Core/Globals.js"], e["Core/Utilities.js"], e["Accessibility/Utils/Announcer.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Accessibility/Utils/EventProvider.js"], e["Accessibility/Components/SeriesComponent/SeriesDescriber.js"]], function(t2, e2, i2, s, n, o) {
        let { composed: r } = t2, { addEvent: a, defined: l, pushUnique: h } = e2, { getChartTitle: c } = s, { defaultPointDescriptionFormatter: d, defaultSeriesDescriptionFormatter: u } = o;
        function p(t3) {
          return !!t3.options.accessibility.announceNewData.enabled;
        }
        class g {
          constructor(t3) {
            this.dirty = { allSeries: {} }, this.lastAnnouncementTime = 0, this.chart = t3;
          }
          init() {
            let t3 = this.chart, e3 = t3.options.accessibility.announceNewData, s2 = e3.interruptUser ? "assertive" : "polite";
            this.lastAnnouncementTime = 0, this.dirty = { allSeries: {} }, this.eventProvider = new n(), this.announcer = new i2(t3, s2), this.addEventListeners();
          }
          destroy() {
            this.eventProvider.removeAddedEvents(), this.announcer.destroy();
          }
          addEventListeners() {
            let t3 = this, e3 = this.chart, i3 = this.eventProvider;
            i3.addEvent(e3, "afterApplyDrilldown", function() {
              t3.lastAnnouncementTime = 0;
            }), i3.addEvent(e3, "afterAddSeries", function(e4) {
              t3.onSeriesAdded(e4.series);
            }), i3.addEvent(e3, "redraw", function() {
              t3.announceDirtyData();
            });
          }
          onSeriesAdded(t3) {
            p(this.chart) && (this.dirty.hasDirty = true, this.dirty.allSeries[t3.name + t3.index] = t3, this.dirty.newSeries = l(this.dirty.newSeries) ? void 0 : t3);
          }
          announceDirtyData() {
            let t3 = this.chart, e3 = this;
            if (t3.options.accessibility.announceNewData && this.dirty.hasDirty) {
              let t4 = this.dirty.newPoint;
              t4 && (t4 = function(t5) {
                let e4 = t5.series.data.filter((e5) => t5.x === e5.x && t5.y === e5.y);
                return 1 === e4.length ? e4[0] : t5;
              }(t4)), this.queueAnnouncement(Object.keys(this.dirty.allSeries).map((t5) => e3.dirty.allSeries[t5]), this.dirty.newSeries, t4), this.dirty = { allSeries: {} };
            }
          }
          queueAnnouncement(t3, e3, i3) {
            let s2 = this.chart, n2 = s2.options.accessibility.announceNewData;
            if (n2.enabled) {
              let s3 = +/* @__PURE__ */ new Date(), o2 = s3 - this.lastAnnouncementTime, r2 = Math.max(0, n2.minAnnounceInterval - o2), a2 = function(t4, e4) {
                let i4 = (t4 || []).concat(e4 || []).reduce((t5, e5) => (t5[e5.name + e5.index] = e5, t5), {});
                return Object.keys(i4).map((t5) => i4[t5]);
              }(this.queuedAnnouncement && this.queuedAnnouncement.series, t3), l2 = this.buildAnnouncementMessage(a2, e3, i3);
              l2 && (this.queuedAnnouncement && clearTimeout(this.queuedAnnouncementTimer), this.queuedAnnouncement = { time: s3, message: l2, series: a2 }, this.queuedAnnouncementTimer = setTimeout(() => {
                this && this.announcer && (this.lastAnnouncementTime = +/* @__PURE__ */ new Date(), this.announcer.announce(this.queuedAnnouncement.message), delete this.queuedAnnouncement, delete this.queuedAnnouncementTimer);
              }, r2));
            }
          }
          buildAnnouncementMessage(e3, i3, s2) {
            let n2 = this.chart, o2 = n2.options.accessibility.announceNewData;
            if (o2.announcementFormatter) {
              let t3 = o2.announcementFormatter(e3, i3, s2);
              if (false !== t3)
                return t3.length ? t3 : null;
            }
            let r2 = t2.charts && t2.charts.length > 1 ? "Multiple" : "Single", a2 = i3 ? "newSeriesAnnounce" + r2 : s2 ? "newPointAnnounce" + r2 : "newDataAnnounce", l2 = c(n2);
            return n2.langFormat("accessibility.announceNewData." + a2, { chartTitle: l2, seriesDesc: i3 ? u(i3) : null, pointDesc: s2 ? d(s2) : null, point: s2, series: i3 });
          }
        }
        return function(t3) {
          function e3(t4) {
            let e4 = this.chart, i4 = this.newDataAnnouncer;
            i4 && i4.chart === e4 && p(e4) && (i4.dirty.newPoint = l(i4.dirty.newPoint) ? void 0 : t4.point);
          }
          function i3() {
            let t4 = this.chart, e4 = this.newDataAnnouncer;
            e4 && e4.chart === t4 && p(t4) && (e4.dirty.hasDirty = true, e4.dirty.allSeries[this.name + this.index] = this);
          }
          t3.compose = function t4(s2) {
            h(r, t4) && (a(s2, "addPoint", e3), a(s2, "updatedData", i3));
          };
        }(g || (g = {})), g;
      }), i(e, "Accessibility/ProxyElement.js", [e["Core/Globals.js"], e["Core/Utilities.js"], e["Accessibility/Utils/EventProvider.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Accessibility/Utils/HTMLUtilities.js"]], function(t2, e2, i2, s, n) {
        let { doc: o } = t2, { attr: r, css: a, merge: l } = e2, { fireEventOnWrappedOrUnwrappedElement: h } = s, { cloneMouseEvent: c, cloneTouchEvent: d, getFakeMouseEvent: u, removeElement: p } = n;
        return class {
          constructor(t3, e3, s2 = "button", n2, r2) {
            this.chart = t3, this.target = e3, this.eventProvider = new i2();
            let a2 = this.innerElement = o.createElement(s2), l2 = this.element = n2 ? o.createElement(n2) : a2;
            t3.styledMode || this.hideElementVisually(a2), n2 && ("li" !== n2 || t3.styledMode || (l2.style.listStyle = "none"), l2.appendChild(a2), this.element = l2), this.updateTarget(e3, r2);
          }
          click() {
            let t3 = this.getTargetPosition();
            t3.x += t3.width / 2, t3.y += t3.height / 2;
            let e3 = u("click", t3);
            h(this.target.click, e3);
          }
          updateTarget(t3, e3) {
            this.target = t3, this.updateCSSClassName();
            let i3 = e3 || {};
            Object.keys(i3).forEach((t4) => {
              null === i3[t4] && delete i3[t4];
            });
            let s2 = this.getTargetAttr(t3.click, "aria-label");
            r(this.innerElement, l(s2 ? { "aria-label": s2 } : {}, i3)), this.eventProvider.removeAddedEvents(), this.addProxyEventsToElement(this.innerElement, t3.click), this.refreshPosition();
          }
          refreshPosition() {
            let t3 = this.getTargetPosition();
            a(this.innerElement, { width: (t3.width || 1) + "px", height: (t3.height || 1) + "px", left: (Math.round(t3.x) || 0) + "px", top: (Math.round(t3.y) || 0) + "px" });
          }
          remove() {
            this.eventProvider.removeAddedEvents(), p(this.element);
          }
          updateCSSClassName() {
            let t3 = (t4) => t4.indexOf("highcharts-no-tooltip") > -1, e3 = this.chart.legend, i3 = e3.group && e3.group.div, s2 = t3(i3 && i3.className || ""), n2 = this.getTargetAttr(this.target.click, "class") || "", o2 = t3(n2);
            this.innerElement.className = s2 || o2 ? "highcharts-a11y-proxy-element highcharts-no-tooltip" : "highcharts-a11y-proxy-element";
          }
          addProxyEventsToElement(t3, e3) {
            ["click", "touchstart", "touchend", "touchcancel", "touchmove", "mouseover", "mouseenter", "mouseleave", "mouseout"].forEach((i3) => {
              let s2 = 0 === i3.indexOf("touch");
              this.eventProvider.addEvent(t3, i3, (t4) => {
                let i4 = s2 ? d(t4) : c(t4);
                e3 && h(e3, i4), t4.stopPropagation(), s2 || t4.preventDefault();
              }, { passive: false });
            });
          }
          hideElementVisually(t3) {
            a(t3, { borderWidth: 0, backgroundColor: "transparent", cursor: "pointer", outline: "none", opacity: 1e-3, filter: "alpha(opacity=1)", zIndex: 999, overflow: "hidden", padding: 0, margin: 0, display: "block", position: "absolute", "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)" });
          }
          getTargetPosition() {
            let t3 = this.target.click, e3 = t3.element ? t3.element : t3, i3 = this.target.visual || e3, s2 = this.chart.renderTo;
            if (s2 && i3 && i3.getBoundingClientRect) {
              let t4 = i3.getBoundingClientRect(), e4 = this.chart.pointer.getChartPosition();
              return { x: (t4.left - e4.left) / e4.scaleX, y: (t4.top - e4.top) / e4.scaleY, width: t4.right / e4.scaleX - t4.left / e4.scaleX, height: t4.bottom / e4.scaleY - t4.top / e4.scaleY };
            }
            return { x: 0, y: 0, width: 1, height: 1 };
          }
          getTargetAttr(t3, e3) {
            return t3.element ? t3.element.getAttribute(e3) : t3.getAttribute(e3);
          }
        };
      }), i(e, "Accessibility/ProxyProvider.js", [e["Core/Globals.js"], e["Core/Utilities.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Accessibility/Utils/DOMElementProvider.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Accessibility/ProxyElement.js"]], function(t2, e2, i2, s, n, o) {
        let { doc: r } = t2, { attr: a, css: l } = e2, { unhideChartElementFromAT: h } = i2, { removeElement: c, removeChildNodes: d } = n;
        return class {
          constructor(t3) {
            this.chart = t3, this.domElementProvider = new s(), this.groups = {}, this.groupOrder = [], this.beforeChartProxyPosContainer = this.createProxyPosContainer("before"), this.afterChartProxyPosContainer = this.createProxyPosContainer("after"), this.update();
          }
          addProxyElement(t3, e3, i3 = "button", s2) {
            let n2 = this.groups[t3];
            if (!n2)
              throw Error("ProxyProvider.addProxyElement: Invalid group key " + t3);
            let r2 = "ul" === n2.type || "ol" === n2.type ? "li" : void 0, a2 = new o(this.chart, e3, i3, r2, s2);
            return n2.proxyContainerElement.appendChild(a2.element), n2.proxyElements.push(a2), a2;
          }
          addGroup(t3, e3 = "div", i3) {
            let s2;
            let n2 = this.groups[t3];
            if (n2)
              return n2.groupElement;
            let o2 = this.domElementProvider.createElement(e3);
            return i3 && i3.role && "div" !== e3 ? (s2 = this.domElementProvider.createElement("div")).appendChild(o2) : s2 = o2, s2.className = "highcharts-a11y-proxy-group highcharts-a11y-proxy-group-" + t3.replace(/\W/g, "-"), this.groups[t3] = { proxyContainerElement: o2, groupElement: s2, type: e3, proxyElements: [] }, a(s2, i3 || {}), "ul" === e3 && o2.setAttribute("role", "list"), this.afterChartProxyPosContainer.appendChild(s2), this.updateGroupOrder(this.groupOrder), s2;
          }
          updateGroupAttrs(t3, e3) {
            let i3 = this.groups[t3];
            if (!i3)
              throw Error("ProxyProvider.updateGroupAttrs: Invalid group key " + t3);
            a(i3.groupElement, e3);
          }
          updateGroupOrder(t3) {
            if (this.groupOrder = t3.slice(), this.isDOMOrderGroupOrder())
              return;
            let e3 = t3.indexOf("series"), i3 = e3 > -1 ? t3.slice(0, e3) : t3, s2 = e3 > -1 ? t3.slice(e3 + 1) : [], n2 = r.activeElement;
            ["before", "after"].forEach((t4) => {
              let e4 = this["before" === t4 ? "beforeChartProxyPosContainer" : "afterChartProxyPosContainer"];
              d(e4), ("before" === t4 ? i3 : s2).forEach((t5) => {
                let i4 = this.groups[t5];
                i4 && e4.appendChild(i4.groupElement);
              });
            }), (this.beforeChartProxyPosContainer.contains(n2) || this.afterChartProxyPosContainer.contains(n2)) && n2 && n2.focus && n2.focus();
          }
          clearGroup(t3) {
            let e3 = this.groups[t3];
            if (!e3)
              throw Error("ProxyProvider.clearGroup: Invalid group key " + t3);
            d(e3.proxyContainerElement);
          }
          removeGroup(t3) {
            let e3 = this.groups[t3];
            e3 && (c(e3.groupElement), delete this.groups[t3]);
          }
          update() {
            this.updatePosContainerPositions(), this.updateGroupOrder(this.groupOrder), this.updateProxyElementPositions();
          }
          updateProxyElementPositions() {
            Object.keys(this.groups).forEach(this.updateGroupProxyElementPositions.bind(this));
          }
          updateGroupProxyElementPositions(t3) {
            let e3 = this.groups[t3];
            e3 && e3.proxyElements.forEach((t4) => t4.refreshPosition());
          }
          destroy() {
            this.domElementProvider.destroyCreatedElements();
          }
          createProxyPosContainer(t3) {
            let e3 = this.domElementProvider.createElement("div");
            return e3.setAttribute("aria-hidden", "false"), e3.className = "highcharts-a11y-proxy-container" + (t3 ? "-" + t3 : ""), l(e3, { top: "0", left: "0" }), this.chart.styledMode || (e3.style.whiteSpace = "nowrap", e3.style.position = "absolute"), e3;
          }
          getCurrentGroupOrderInDOM() {
            let t3 = (t4) => {
              let e4 = Object.keys(this.groups), i4 = e4.length;
              for (; i4--; ) {
                let s3 = e4[i4], n2 = this.groups[s3];
                if (n2 && t4 === n2.groupElement)
                  return s3;
              }
            }, e3 = (e4) => {
              let i4 = [], s3 = e4.children;
              for (let e5 = 0; e5 < s3.length; ++e5) {
                let n2 = t3(s3[e5]);
                n2 && i4.push(n2);
              }
              return i4;
            }, i3 = e3(this.beforeChartProxyPosContainer), s2 = e3(this.afterChartProxyPosContainer);
            return i3.push("series"), i3.concat(s2);
          }
          isDOMOrderGroupOrder() {
            let t3 = this.getCurrentGroupOrderInDOM(), e3 = this.groupOrder.filter((t4) => "series" === t4 || !!this.groups[t4]), i3 = t3.length;
            if (i3 !== e3.length)
              return false;
            for (; i3--; )
              if (t3[i3] !== e3[i3])
                return false;
            return true;
          }
          updatePosContainerPositions() {
            let t3 = this.chart;
            if (t3.renderer.forExport)
              return;
            let e3 = t3.renderer.box;
            t3.container.insertBefore(this.afterChartProxyPosContainer, e3.nextSibling), t3.container.insertBefore(this.beforeChartProxyPosContainer, e3), h(this.chart, this.afterChartProxyPosContainer), h(this.chart, this.beforeChartProxyPosContainer);
          }
        };
      }), i(e, "Stock/RangeSelector/RangeSelectorDefaults.js", [], function() {
        return { lang: { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "", rangeSelectorTo: "→" }, rangeSelector: { allButtonsEnabled: false, buttons: void 0, buttonSpacing: 5, dropdown: "responsive", enabled: void 0, verticalAlign: "top", buttonTheme: { width: 28, height: 18, padding: 2, zIndex: 7 }, floating: false, x: 0, y: 0, height: void 0, inputBoxBorderColor: "none", inputBoxHeight: 17, inputBoxWidth: void 0, inputDateFormat: "%e %b %Y", inputDateParser: void 0, inputEditDateFormat: "%Y-%m-%d", inputEnabled: true, inputPosition: { align: "right", x: 0, y: 0 }, inputSpacing: 5, selected: void 0, buttonPosition: { align: "left", x: 0, y: 0 }, inputStyle: { color: "#334eff", cursor: "pointer", fontSize: "0.8em" }, labelStyle: { color: "#666666", fontSize: "0.8em" } } };
      }), i(e, "Stock/RangeSelector/RangeSelectorComposition.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Stock/RangeSelector/RangeSelectorDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s) {
        let n;
        let { defaultOptions: o } = t2, { composed: r } = e2, { addEvent: a, defined: l, extend: h, find: c, isNumber: d, merge: u, pick: p, pushUnique: g } = s, m = [];
        function b() {
          let t3, e3;
          let i3 = this.range, s2 = i3.type, n2 = this.max, o2 = this.chart.time, r2 = function(t4, e4) {
            let i4 = "year" === s2 ? "FullYear" : "Month", n3 = new o2.Date(t4), r3 = o2.get(i4, n3);
            return o2.set(i4, n3, r3 + e4), r3 === o2.get(i4, n3) && o2.set("Date", n3, 0), n3.getTime() - t4;
          };
          d(i3) ? (t3 = n2 - i3, e3 = i3) : i3 && (t3 = n2 + r2(n2, -(i3.count || 1)), this.chart && (this.chart.fixedRange = n2 - t3));
          let a2 = p(this.dataMin, Number.MIN_VALUE);
          return d(t3) || (t3 = a2), t3 <= a2 && (t3 = a2, void 0 === e3 && (e3 = r2(t3, i3.count)), this.newMax = Math.min(t3 + e3, p(this.dataMax, Number.MAX_VALUE))), d(n2) ? !d(i3) && i3 && i3._offsetMin && (t3 += i3._offsetMin) : t3 = void 0, t3;
        }
        function f() {
          this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new n(this));
        }
        function x() {
          let t3 = this.axes, e3 = this.rangeSelector;
          if (e3) {
            d(e3.deferredYTDClick) && (e3.clickButton(e3.deferredYTDClick), delete e3.deferredYTDClick), t3.forEach((t4) => {
              t4.updateNames(), t4.setScale();
            }), this.getAxisMargins(), e3.render();
            let i3 = e3.options.verticalAlign;
            e3.options.floating || ("bottom" === i3 ? this.extraBottomMargin = true : "middle" === i3 || (this.extraTopMargin = true));
          }
        }
        function y(t3) {
          let e3, i3, s2, n2;
          let o2 = t3.rangeSelector, r2 = () => {
            o2 && (e3 = t3.xAxis[0].getExtremes(), i3 = t3.legend, n2 = o2 && o2.options.verticalAlign, d(e3.min) && o2.render(e3.min, e3.max), i3.display && "top" === n2 && n2 === i3.options.verticalAlign && (s2 = u(t3.spacingBox), "vertical" === i3.options.layout ? s2.y = t3.plotTop : s2.y += o2.getHeight(), i3.group.placed = false, i3.align(s2)));
          };
          if (o2) {
            let e4 = c(m, (e5) => e5[0] === t3);
            e4 || m.push([t3, [a(t3.xAxis[0], "afterSetExtremes", function(t4) {
              o2 && o2.render(t4.min, t4.max);
            }), a(t3, "redraw", r2)]]), r2();
          }
        }
        function v() {
          for (let t3 = 0, e3 = m.length; t3 < e3; ++t3) {
            let e4 = m[t3];
            if (e4[0] === this) {
              e4[1].forEach((t4) => t4()), m.splice(t3, 1);
              return;
            }
          }
        }
        function A() {
          let t3 = this.rangeSelector;
          if (t3) {
            let e3 = t3.getHeight();
            this.extraTopMargin && (this.plotTop += e3), this.extraBottomMargin && (this.marginBottom += e3);
          }
        }
        function w() {
          let t3 = this.rangeSelector;
          if (t3 && !t3.options.floating) {
            t3.render();
            let e3 = t3.options.verticalAlign;
            "bottom" === e3 ? this.extraBottomMargin = true : "middle" !== e3 && (this.extraTopMargin = true);
          }
        }
        function C(t3) {
          let e3 = t3.options, i3 = e3.rangeSelector, s2 = this.extraBottomMargin, o2 = this.extraTopMargin, r2 = this.rangeSelector;
          if (i3 && i3.enabled && !l(r2) && this.options.rangeSelector && (this.options.rangeSelector.enabled = true, this.rangeSelector = r2 = new n(this)), this.extraBottomMargin = false, this.extraTopMargin = false, r2) {
            y(this);
            let t4 = i3 && i3.verticalAlign || r2.options && r2.options.verticalAlign;
            r2.options.floating || ("bottom" === t4 ? this.extraBottomMargin = true : "middle" === t4 || (this.extraTopMargin = true)), (this.extraBottomMargin !== s2 || this.extraTopMargin !== o2) && (this.isDirtyBox = true);
          }
        }
        return { compose: function t3(e3, s2, l2) {
          if (n = l2, g(r, t3)) {
            let t4 = s2.prototype;
            e3.prototype.minFromRange = b, a(s2, "afterGetContainer", f), a(s2, "beforeRender", x), a(s2, "destroy", v), a(s2, "getMargins", A), a(s2, "render", w), a(s2, "update", C), t4.callbacks.push(y), h(o, { rangeSelector: i2.rangeSelector }), h(o.lang, i2.lang);
          }
        } };
      }), i(e, "Stock/RangeSelector/RangeSelector.js", [e["Core/Axis/Axis.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Stock/RangeSelector/RangeSelectorComposition.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n, o) {
        let { defaultOptions: r } = e2, { addEvent: a, createElement: l, css: h, defined: c, destroyObjectProperties: d, discardElement: u, extend: p, fireEvent: g, isNumber: m, merge: b, objectEach: f, pad: x, pick: y, pInt: v, splat: A } = o;
        class w {
          static compose(t3, e3) {
            s.compose(t3, e3, w);
          }
          constructor(t3) {
            this.buttonOptions = w.prototype.defaultButtons, this.initialButtonGroupWidth = 0, this.chart = t3, this.init(t3);
          }
          clickButton(e3, i3) {
            let s2 = this.chart, n2 = this.buttonOptions[e3], o2 = s2.xAxis[0], r2 = s2.scroller && s2.scroller.getUnionExtremes() || o2 || {}, l2 = n2.type, h2 = n2.dataGrouping, d2 = r2.dataMin, u2 = r2.dataMax, p2, b2 = o2 && Math.round(Math.min(o2.max, y(u2, o2.max))), f2, x2 = n2._range, v2, w2, C, E, T, M = true;
            if (null !== d2 && null !== u2) {
              if (s2.fixedRange = x2, this.setSelected(e3), h2 && (this.forcedDataGrouping = true, t2.prototype.setDataGrouping.call(o2 || { chart: this.chart }, h2, false), this.frozenStates = n2.preserveDataGrouping), "month" === l2 || "year" === l2)
                o2 ? (E = { range: n2, max: b2, chart: s2, dataMin: d2, dataMax: u2 }, p2 = o2.minFromRange.call(E), m(E.newMax) && (b2 = E.newMax), M = false) : x2 = n2;
              else if (x2)
                b2 = Math.min((p2 = Math.max(b2 - x2, d2)) + x2, u2), M = false;
              else if ("ytd" === l2) {
                if (o2)
                  (void 0 === u2 || void 0 === d2) && (d2 = Number.MAX_VALUE, u2 = Number.MIN_VALUE, s2.series.forEach((t3) => {
                    let e4 = t3.xData;
                    e4 && (d2 = Math.min(e4[0], d2), u2 = Math.max(e4[e4.length - 1], u2));
                  }), i3 = false), p2 = v2 = (T = this.getYTDExtremes(u2, d2, s2.time.useUTC)).min, b2 = T.max;
                else {
                  this.deferredYTDClick = e3;
                  return;
                }
              } else
                "all" === l2 && o2 && (s2.navigator && s2.navigator.baseSeries[0] && (s2.navigator.baseSeries[0].xAxis.options.range = void 0), p2 = d2, b2 = u2);
              M && n2._offsetMin && c(p2) && (p2 += n2._offsetMin), n2._offsetMax && c(b2) && (b2 += n2._offsetMax), this.dropdown && (this.dropdown.selectedIndex = e3 + 1), o2 ? o2.setExtremes(p2, b2, y(i3, true), void 0, { trigger: "rangeSelectorButton", rangeSelectorButton: n2 }) : (C = (f2 = A(s2.options.xAxis)[0]).range, f2.range = x2, w2 = f2.min, f2.min = v2, a(s2, "load", function() {
                f2.range = C, f2.min = w2;
              })), g(this, "afterBtnClick");
            }
          }
          setSelected(t3) {
            this.selected = this.options.selected = t3;
          }
          init(t3) {
            let e3 = this, i3 = t3.options.rangeSelector, s2 = i3.buttons || e3.defaultButtons.slice(), n2 = i3.selected, o2 = function() {
              let t4 = e3.minInput, i4 = e3.maxInput;
              t4 && t4.blur && g(t4, "blur"), i4 && i4.blur && g(i4, "blur");
            };
            e3.chart = t3, e3.options = i3, e3.buttons = [], e3.buttonOptions = s2, this.eventsToUnbind = [], this.eventsToUnbind.push(a(t3.container, "mousedown", o2)), this.eventsToUnbind.push(a(t3, "resize", o2)), s2.forEach(e3.computeButtonRange), void 0 !== n2 && s2[n2] && this.clickButton(n2, false), this.eventsToUnbind.push(a(t3, "load", function() {
              t3.xAxis && t3.xAxis[0] && a(t3.xAxis[0], "setExtremes", function(i4) {
                this.max - this.min !== t3.fixedRange && "rangeSelectorButton" !== i4.trigger && "updatedData" !== i4.trigger && e3.forcedDataGrouping && !e3.frozenStates && this.setDataGrouping(false, false);
              });
            }));
          }
          updateButtonStates() {
            let t3 = this, e3 = this.chart, i3 = this.dropdown, s2 = e3.xAxis[0], n2 = Math.round(s2.max - s2.min), o2 = !s2.hasVisibleSeries, r2 = 24 * 36e5, a2 = e3.scroller && e3.scroller.getUnionExtremes() || s2, l2 = a2.dataMin, h2 = a2.dataMax, d2 = t3.getYTDExtremes(h2, l2, e3.time.useUTC), u2 = d2.min, p2 = d2.max, g2 = t3.selected, b2 = t3.options.allButtonsEnabled, f2 = t3.buttons, x2 = m(g2), y2 = false;
            t3.buttonOptions.forEach((e4, a3) => {
              let d3 = e4._range, m2 = e4.type, v2 = e4.count || 1, A2 = f2[a3], w2 = e4._offsetMax - e4._offsetMin, C = a3 === g2, E = d3 > h2 - l2, T = d3 < s2.minRange, M = 0, S = false, k = false, P = d3 === n2;
              C && E && (y2 = true), ("month" === m2 || "year" === m2) && n2 + 36e5 >= { month: 28, year: 365 }[m2] * r2 * v2 - w2 && n2 - 36e5 <= { month: 31, year: 366 }[m2] * r2 * v2 + w2 ? P = true : "ytd" === m2 ? (P = p2 - u2 + w2 === n2, S = !C) : "all" === m2 && (P = s2.max - s2.min >= h2 - l2, k = !C && x2 && P);
              let B = !b2 && !(y2 && "all" === m2) && (E || T || k || o2), D = y2 && "all" === m2 || C && P || P && !x2 && !S || C && t3.frozenStates;
              B ? M = 3 : D && (x2 = true, M = 2), A2.state !== M && (A2.setState(M), i3 && (i3.options[a3 + 1].disabled = B, 2 === M && (i3.selectedIndex = a3 + 1)), 0 === M && g2 === a3 ? t3.setSelected() : (2 === M && !c(g2) || y2) && t3.setSelected(a3));
            });
          }
          computeButtonRange(t3) {
            let e3 = t3.type, i3 = t3.count || 1, s2 = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5 };
            s2[e3] ? t3._range = s2[e3] * i3 : ("month" === e3 || "year" === e3) && (t3._range = 24 * { month: 30, year: 365 }[e3] * 36e5 * i3), t3._offsetMin = y(t3.offsetMin, 0), t3._offsetMax = y(t3.offsetMax, 0), t3._range += t3._offsetMax - t3._offsetMin;
          }
          getInputValue(t3) {
            let e3 = "min" === t3 ? this.minInput : this.maxInput, i3 = this.chart.options.rangeSelector, s2 = this.chart.time;
            return e3 ? ("text" === e3.type && i3.inputDateParser || this.defaultInputDateParser)(e3.value, s2.useUTC, s2) : 0;
          }
          setInputValue(t3, e3) {
            let i3 = this.options, s2 = this.chart.time, n2 = "min" === t3 ? this.minInput : this.maxInput, o2 = "min" === t3 ? this.minDateBox : this.maxDateBox;
            if (n2) {
              let t4 = n2.getAttribute("data-hc-time"), r2 = c(t4) ? Number(t4) : void 0;
              if (c(e3)) {
                let t5 = r2;
                c(t5) && n2.setAttribute("data-hc-time-previous", t5), n2.setAttribute("data-hc-time", e3), r2 = e3;
              }
              n2.value = s2.dateFormat(this.inputTypeFormats[n2.type] || i3.inputEditDateFormat, r2), o2 && o2.attr({ text: s2.dateFormat(i3.inputDateFormat, r2) });
            }
          }
          setInputExtremes(t3, e3, i3) {
            let s2 = "min" === t3 ? this.minInput : this.maxInput;
            if (s2) {
              let t4 = this.inputTypeFormats[s2.type], n2 = this.chart.time;
              if (t4) {
                let o2 = n2.dateFormat(t4, e3);
                s2.min !== o2 && (s2.min = o2);
                let r2 = n2.dateFormat(t4, i3);
                s2.max !== r2 && (s2.max = r2);
              }
            }
          }
          showInput(t3) {
            let e3 = "min" === t3 ? this.minDateBox : this.maxDateBox, i3 = "min" === t3 ? this.minInput : this.maxInput;
            if (i3 && e3 && this.inputGroup) {
              let t4 = "text" === i3.type, { translateX: s2 = 0, translateY: n2 = 0 } = this.inputGroup, { x: o2 = 0, width: r2 = 0, height: a2 = 0 } = e3, { inputBoxWidth: l2 } = this.options;
              h(i3, { width: t4 ? r2 + (l2 ? -2 : 20) + "px" : "auto", height: a2 - 2 + "px", border: "2px solid silver" }), t4 && l2 ? h(i3, { left: s2 + o2 + "px", top: n2 + "px" }) : h(i3, { left: Math.min(Math.round(o2 + s2 - (i3.offsetWidth - r2) / 2), this.chart.chartWidth - i3.offsetWidth) + "px", top: n2 - (i3.offsetHeight - a2) / 2 + "px" });
            }
          }
          hideInput(t3) {
            let e3 = "min" === t3 ? this.minInput : this.maxInput;
            e3 && h(e3, { top: "-9999em", border: 0, width: "1px", height: "1px" });
          }
          defaultInputDateParser(t3, e3, s2) {
            let n2 = t3.split("/").join("-").split(" ").join("T");
            if (-1 === n2.indexOf("T") && (n2 += "T00:00"), e3)
              n2 += "Z";
            else {
              var o2;
              if (i2.isSafari && (!((o2 = n2).length > 6) || o2.lastIndexOf("-") !== o2.length - 6 && o2.lastIndexOf("+") !== o2.length - 6)) {
                let t4 = new Date(n2).getTimezoneOffset() / 60;
                n2 += t4 <= 0 ? `+${x(-t4)}:00` : `-${x(t4)}:00`;
              }
            }
            let r2 = Date.parse(n2);
            if (!m(r2)) {
              let e4 = t3.split("-");
              r2 = Date.UTC(v(e4[0]), v(e4[1]) - 1, v(e4[2]));
            }
            return s2 && e3 && m(r2) && (r2 += s2.getTimezoneOffset(r2)), r2;
          }
          drawInput(t3) {
            let { chart: e3, div: s2, inputGroup: n2 } = this, o2 = this, a2 = e3.renderer.style || {}, c2 = e3.renderer, d2 = e3.options.rangeSelector, u2 = r.lang, g2 = "min" === t3;
            function f2() {
              let { maxInput: i3, minInput: s3 } = o2, n3 = e3.xAxis[0], r2 = e3.scroller && e3.scroller.getUnionExtremes() || n3, a3 = r2.dataMin, l2 = r2.dataMax, h2 = o2.getInputValue(t3);
              h2 !== Number(A2.getAttribute("data-hc-time-previous")) && m(h2) && (A2.setAttribute("data-hc-time-previous", h2), g2 && i3 && m(a3) ? h2 > Number(i3.getAttribute("data-hc-time")) ? h2 = void 0 : h2 < a3 && (h2 = a3) : s3 && m(l2) && (h2 < Number(s3.getAttribute("data-hc-time")) ? h2 = void 0 : h2 > l2 && (h2 = l2)), void 0 !== h2 && n3.setExtremes(g2 ? h2 : n3.min, g2 ? n3.max : h2, void 0, void 0, { trigger: "rangeSelectorInput" }));
            }
            let x2 = u2[g2 ? "rangeSelectorFrom" : "rangeSelectorTo"] || "", y2 = c2.label(x2, 0).addClass("highcharts-range-label").attr({ padding: x2 ? 2 : 0, height: x2 ? d2.inputBoxHeight : 0 }).add(n2), v2 = c2.label("", 0).addClass("highcharts-range-input").attr({ padding: 2, width: d2.inputBoxWidth, height: d2.inputBoxHeight, "text-align": "center" }).on("click", function() {
              o2.showInput(t3), o2[t3 + "Input"].focus();
            });
            e3.styledMode || v2.attr({ stroke: d2.inputBoxBorderColor, "stroke-width": 1 }), v2.add(n2);
            let A2 = l("input", { name: t3, className: "highcharts-range-selector" }, void 0, s2);
            A2.setAttribute("type", function(t4) {
              let e4 = -1 !== t4.indexOf("%L");
              if (e4)
                return "text";
              let i3 = ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some((e5) => -1 !== t4.indexOf("%" + e5)), s3 = ["H", "k", "I", "l", "M", "S"].some((e5) => -1 !== t4.indexOf("%" + e5));
              return i3 && s3 ? "datetime-local" : i3 ? "date" : s3 ? "time" : "text";
            }(d2.inputDateFormat || "%e %b %Y")), e3.styledMode || (y2.css(b(a2, d2.labelStyle)), v2.css(b({ color: "#333333" }, a2, d2.inputStyle)), h(A2, p({ position: "absolute", border: 0, boxShadow: "0 0 15px rgba(0,0,0,0.3)", width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: a2.fontSize, fontFamily: a2.fontFamily, top: "-9999em" }, d2.inputStyle))), A2.onfocus = () => {
              o2.showInput(t3);
            }, A2.onblur = () => {
              A2 === i2.doc.activeElement && f2(), o2.hideInput(t3), o2.setInputValue(t3), A2.blur();
            };
            let w2 = false;
            return A2.onchange = () => {
              w2 || (f2(), o2.hideInput(t3), A2.blur());
            }, A2.onkeypress = (t4) => {
              13 === t4.keyCode && f2();
            }, A2.onkeydown = (t4) => {
              w2 = true, (38 === t4.keyCode || 40 === t4.keyCode) && f2();
            }, A2.onkeyup = () => {
              w2 = false;
            }, { dateBox: v2, input: A2, label: y2 };
          }
          getPosition() {
            let t3 = this.chart, e3 = t3.options.rangeSelector, i3 = "top" === e3.verticalAlign ? t3.plotTop - t3.axisOffset[0] : 0;
            return { buttonTop: i3 + e3.buttonPosition.y, inputTop: i3 + e3.inputPosition.y - 10 };
          }
          getYTDExtremes(t3, e3, i3) {
            let s2 = this.chart.time, n2 = new s2.Date(t3), o2 = s2.get("FullYear", n2), r2 = i3 ? s2.Date.UTC(o2, 0, 1) : +new s2.Date(o2, 0, 1), a2 = n2.getTime();
            return { max: Math.min(t3 || a2, a2), min: Math.max(e3, r2) };
          }
          render(t3, e3) {
            let i3 = this.chart, s2 = i3.renderer, n2 = i3.container, o2 = i3.options, r2 = o2.rangeSelector, a2 = y(o2.chart.style && o2.chart.style.zIndex, 0) + 1, h2 = r2.inputEnabled, d2 = this.rendered;
            if (false !== r2.enabled) {
              if (!d2 && (this.group = s2.g("range-selector-group").attr({ zIndex: 7 }).add(), this.div = l("div", void 0, { position: "relative", height: 0, zIndex: a2 }), this.buttonOptions.length && this.renderButtons(), n2.parentNode && n2.parentNode.insertBefore(this.div, n2), h2)) {
                this.inputGroup = s2.g("input-group").add(this.group);
                let t4 = this.drawInput("min");
                this.minDateBox = t4.dateBox, this.minLabel = t4.label, this.minInput = t4.input;
                let e4 = this.drawInput("max");
                this.maxDateBox = e4.dateBox, this.maxLabel = e4.label, this.maxInput = e4.input;
              }
              if (h2) {
                this.setInputValue("min", t3), this.setInputValue("max", e3);
                let s3 = i3.scroller && i3.scroller.getUnionExtremes() || i3.xAxis[0] || {};
                if (c(s3.dataMin) && c(s3.dataMax)) {
                  let t4 = i3.xAxis[0].minRange || 0;
                  this.setInputExtremes("min", s3.dataMin, Math.min(s3.dataMax, this.getInputValue("max")) - t4), this.setInputExtremes("max", Math.max(s3.dataMin, this.getInputValue("min")) + t4, s3.dataMax);
                }
                if (this.inputGroup) {
                  let t4 = 0;
                  [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach((e4) => {
                    if (e4) {
                      let { width: i4 } = e4.getBBox();
                      i4 && (e4.attr({ x: t4 }), t4 += i4 + r2.inputSpacing);
                    }
                  });
                }
              }
              this.alignElements(), this.rendered = true;
            }
          }
          renderButtons() {
            let { buttons: t3, chart: e3, options: s2 } = this, n2 = r.lang, o2 = e3.renderer, h2 = b(s2.buttonTheme), c2 = h2 && h2.states, d2 = h2.width || 28;
            delete h2.width, delete h2.states, this.buttonGroup = o2.g("range-selector-buttons").add(this.group);
            let u2 = this.dropdown = l("select", void 0, { position: "absolute", width: "1px", height: "1px", padding: 0, border: 0, top: "-9999em", cursor: "pointer", opacity: 1e-4 }, this.div);
            a(u2, "touchstart", () => {
              u2.style.fontSize = "16px";
            }), [[i2.isMS ? "mouseover" : "mouseenter"], [i2.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(([e4, i3]) => {
              a(u2, e4, () => {
                let s3 = t3[this.currentButtonIndex()];
                s3 && g(s3.element, i3 || e4);
              });
            }), this.zoomText = o2.label(n2 && n2.rangeSelectorZoom || "", 0).attr({ padding: s2.buttonTheme.padding, height: s2.buttonTheme.height, paddingLeft: 0, paddingRight: 0 }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(s2.labelStyle), h2["stroke-width"] = y(h2["stroke-width"], 0)), l("option", { textContent: this.zoomText.textStr, disabled: true }, void 0, u2), this.buttonOptions.forEach((e4, i3) => {
              l("option", { textContent: e4.title || e4.text }, void 0, u2), t3[i3] = o2.button(e4.text, 0, 0, (t4) => {
                let s3;
                let n3 = e4.events && e4.events.click;
                n3 && (s3 = n3.call(e4, t4)), false !== s3 && this.clickButton(i3), this.isActive = true;
              }, h2, c2 && c2.hover, c2 && c2.select, c2 && c2.disabled).attr({ "text-align": "center", width: d2 }).add(this.buttonGroup), e4.title && t3[i3].attr("title", e4.title);
            });
          }
          alignElements() {
            let { buttonGroup: t3, buttons: e3, chart: i3, group: s2, inputGroup: n2, options: o2, zoomText: r2 } = this, a2 = i3.options, l2 = a2.exporting && false !== a2.exporting.enabled && a2.navigation && a2.navigation.buttonOptions, { buttonPosition: h2, inputPosition: c2, verticalAlign: d2 } = o2, u2 = (t4, e4) => l2 && this.titleCollision(i3) && "top" === d2 && "right" === e4.align && e4.y - t4.getBBox().height - 12 < (l2.y || 0) + (l2.height || 0) + i3.spacing[0] ? -40 : 0, p2 = i3.plotLeft;
            if (s2 && h2 && c2) {
              let a3 = h2.x - i3.spacing[3];
              if (t3) {
                if (this.positionButtons(), !this.initialButtonGroupWidth) {
                  let t4 = 0;
                  r2 && (t4 += r2.getBBox().width + 5), e3.forEach((i4, s3) => {
                    t4 += i4.width || 0, s3 !== e3.length - 1 && (t4 += o2.buttonSpacing);
                  }), this.initialButtonGroupWidth = t4;
                }
                p2 -= i3.spacing[3], this.updateButtonStates();
                let n3 = u2(t3, h2);
                this.alignButtonGroup(n3), s2.placed = t3.placed = i3.hasLoaded;
              }
              let l3 = 0;
              n2 && (l3 = u2(n2, c2), "left" === c2.align ? a3 = p2 : "right" === c2.align && (a3 = -Math.max(i3.axisOffset[1], -l3)), n2.align({ y: c2.y, width: n2.getBBox().width, align: c2.align, x: c2.x + a3 - 2 }, true, i3.spacingBox), n2.placed = i3.hasLoaded), this.handleCollision(l3), s2.align({ verticalAlign: d2 }, true, i3.spacingBox);
              let g2 = s2.alignAttr.translateY, m2 = s2.getBBox().height + 20, b2 = 0;
              if ("bottom" === d2) {
                let t4 = i3.legend && i3.legend.options, e4 = t4 && "bottom" === t4.verticalAlign && t4.enabled && !t4.floating ? i3.legend.legendHeight + y(t4.margin, 10) : 0;
                b2 = g2 - (m2 = m2 + e4 - 20) - (o2.floating ? 0 : o2.y) - (i3.titleOffset ? i3.titleOffset[2] : 0) - 10;
              }
              "top" === d2 ? (o2.floating && (b2 = 0), i3.titleOffset && i3.titleOffset[0] && (b2 = i3.titleOffset[0]), b2 += i3.margin[0] - i3.spacing[0] || 0) : "middle" === d2 && (c2.y === h2.y ? b2 = g2 : (c2.y || h2.y) && (c2.y < 0 || h2.y < 0 ? b2 -= Math.min(c2.y, h2.y) : b2 = g2 - m2)), s2.translate(o2.x, o2.y + Math.floor(b2));
              let { minInput: f2, maxInput: x2, dropdown: v2 } = this;
              o2.inputEnabled && f2 && x2 && (f2.style.marginTop = s2.translateY + "px", x2.style.marginTop = s2.translateY + "px"), v2 && (v2.style.marginTop = s2.translateY + "px");
            }
          }
          alignButtonGroup(t3, e3) {
            let { chart: i3, options: s2, buttonGroup: n2, buttons: o2 } = this, { buttonPosition: r2 } = s2, a2 = i3.plotLeft - i3.spacing[3], l2 = r2.x - i3.spacing[3];
            "right" === r2.align ? l2 += t3 - a2 : "center" === r2.align && (l2 -= a2 / 2), n2 && n2.align({ y: r2.y, width: y(e3, this.initialButtonGroupWidth), align: r2.align, x: l2 }, true, i3.spacingBox);
          }
          positionButtons() {
            let { buttons: t3, chart: e3, options: i3, zoomText: s2 } = this, n2 = e3.hasLoaded ? "animate" : "attr", { buttonPosition: o2 } = i3, r2 = e3.plotLeft, a2 = r2;
            s2 && "hidden" !== s2.visibility && (s2[n2]({ x: y(r2 + o2.x, r2) }), a2 += o2.x + s2.getBBox().width + 5);
            for (let e4 = 0, s3 = this.buttonOptions.length; e4 < s3; ++e4)
              "hidden" !== t3[e4].visibility ? (t3[e4][n2]({ x: a2 }), a2 += (t3[e4].width || 0) + i3.buttonSpacing) : t3[e4][n2]({ x: r2 });
          }
          handleCollision(t3) {
            let { chart: e3, buttonGroup: i3, inputGroup: s2 } = this, { buttonPosition: n2, dropdown: o2, inputPosition: r2 } = this.options, a2 = () => {
              let t4 = 0;
              return this.buttons.forEach((e4) => {
                let i4 = e4.getBBox();
                i4.width > t4 && (t4 = i4.width);
              }), t4;
            }, l2 = (e4) => {
              if (s2 && i3) {
                let o3 = s2.alignAttr.translateX + s2.alignOptions.x - t3 + s2.getBBox().x + 2, a3 = s2.alignOptions.width, l3 = i3.alignAttr.translateX + i3.getBBox().x;
                return l3 + e4 > o3 && o3 + a3 > l3 && n2.y < r2.y + s2.getBBox().height;
              }
              return false;
            }, h2 = () => {
              s2 && i3 && s2.attr({ translateX: s2.alignAttr.translateX + (e3.axisOffset[1] >= -t3 ? 0 : -t3), translateY: s2.alignAttr.translateY + i3.getBBox().height + 10 });
            };
            if (i3) {
              if ("always" === o2) {
                this.collapseButtons(t3), l2(a2()) && h2();
                return;
              }
              "never" === o2 && this.expandButtons();
            }
            s2 && i3 ? r2.align === n2.align || l2(this.initialButtonGroupWidth + 20) ? "responsive" === o2 ? (this.collapseButtons(t3), l2(a2()) && h2()) : h2() : "responsive" === o2 && this.expandButtons() : i3 && "responsive" === o2 && (this.initialButtonGroupWidth > e3.plotWidth ? this.collapseButtons(t3) : this.expandButtons());
          }
          collapseButtons(t3) {
            let { buttons: e3, buttonOptions: i3, chart: s2, dropdown: n2, options: o2, zoomText: r2 } = this;
            if (true === this.isCollapsed)
              return;
            this.isCollapsed = true;
            let a2 = s2.userOptions.rangeSelector && s2.userOptions.rangeSelector.buttonTheme || {}, l2 = (t4) => ({ text: t4 ? `${t4} ▾` : "▾", width: "auto", paddingLeft: y(o2.buttonTheme.paddingLeft, a2.padding, 8), paddingRight: y(o2.buttonTheme.paddingRight, a2.padding, 8) });
            r2 && r2.hide();
            let h2 = false;
            i3.forEach((t4, i4) => {
              let s3 = e3[i4];
              2 !== s3.state ? s3.hide() : (s3.show(), s3.attr(l2(t4.text)), h2 = true);
            }), h2 || (n2 && (n2.selectedIndex = 0), e3[0].show(), e3[0].attr(l2(this.zoomText && this.zoomText.textStr)));
            let { align: c2 } = o2.buttonPosition;
            this.positionButtons(), ("right" === c2 || "center" === c2) && this.alignButtonGroup(t3, e3[this.currentButtonIndex()].getBBox().width), this.showDropdown();
          }
          expandButtons() {
            let { buttons: t3, buttonOptions: e3, options: i3, zoomText: s2 } = this;
            this.hideDropdown(), false !== this.isCollapsed && (this.isCollapsed = false, s2 && s2.show(), e3.forEach((e4, s3) => {
              let n2 = t3[s3];
              n2.show(), n2.attr({ text: e4.text, width: i3.buttonTheme.width || 28, paddingLeft: y(i3.buttonTheme.paddingLeft, "unset"), paddingRight: y(i3.buttonTheme.paddingRight, "unset") }), n2.state < 2 && n2.setState(0);
            }), this.positionButtons());
          }
          currentButtonIndex() {
            let { dropdown: t3 } = this;
            return t3 && t3.selectedIndex > 0 ? t3.selectedIndex - 1 : 0;
          }
          showDropdown() {
            let { buttonGroup: t3, buttons: e3, chart: i3, dropdown: s2 } = this;
            if (t3 && s2) {
              let { translateX: n2 = 0, translateY: o2 = 0 } = t3, r2 = e3[this.currentButtonIndex()].getBBox();
              h(s2, { left: i3.plotLeft + n2 + "px", top: o2 + 0.5 + "px", width: r2.width + "px", height: r2.height + "px" }), this.hasVisibleDropdown = true;
            }
          }
          hideDropdown() {
            let { dropdown: t3 } = this;
            t3 && (h(t3, { top: "-9999em", width: "1px", height: "1px" }), this.hasVisibleDropdown = false);
          }
          getHeight() {
            let t3 = this.options, e3 = this.group, i3 = t3.inputPosition, s2 = t3.buttonPosition, n2 = t3.y, o2 = s2.y, r2 = i3.y, a2 = 0;
            return t3.height ? t3.height : (this.alignElements(), a2 = e3 ? e3.getBBox(true).height + 13 + n2 : 0, (r2 < 0 && o2 < 0 || r2 > 0 && o2 > 0) && (a2 += Math.abs(Math.min(r2, o2))), a2);
          }
          titleCollision(t3) {
            return !(t3.options.title.text || t3.options.subtitle.text);
          }
          update(t3) {
            let e3 = this.chart;
            b(true, e3.options.rangeSelector, t3), this.destroy(), this.init(e3), this.render();
          }
          destroy() {
            let t3 = this, e3 = t3.minInput, i3 = t3.maxInput;
            t3.eventsToUnbind && (t3.eventsToUnbind.forEach((t4) => t4()), t3.eventsToUnbind = void 0), d(t3.buttons), e3 && (e3.onfocus = e3.onblur = e3.onchange = null), i3 && (i3.onfocus = i3.onblur = i3.onchange = null), f(t3, function(e4, i4) {
              e4 && "chart" !== i4 && (e4 instanceof n ? e4.destroy() : e4 instanceof window.HTMLElement && u(e4)), e4 !== w.prototype[i4] && (t3[i4] = null);
            }, this);
          }
        }
        return p(w.prototype, { defaultButtons: [{ type: "month", count: 1, text: "1m", title: "View 1 month" }, { type: "month", count: 3, text: "3m", title: "View 3 months" }, { type: "month", count: 6, text: "6m", title: "View 6 months" }, { type: "ytd", text: "YTD", title: "View year to date" }, { type: "year", count: 1, text: "1y", title: "View 1 year" }, { type: "all", text: "All", title: "View all" }], inputTypeFormats: { "datetime-local": "%Y-%m-%dT%H:%M:%S", date: "%Y-%m-%d", time: "%H:%M:%S" } }), w;
      }), i(e, "Accessibility/Components/RangeSelectorComponent.js", [e["Accessibility/AccessibilityComponent.js"], e["Accessibility/Utils/Announcer.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Core/Globals.js"], e["Accessibility/KeyboardNavigationHandler.js"], e["Stock/RangeSelector/RangeSelector.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n, o, r) {
        let { unhideChartElementFromAT: a, getAxisRangeDescription: l } = i2, { composed: h } = s, { addEvent: c, attr: d, pushUnique: u } = r;
        class p extends t2 {
          init() {
            let t3 = this.chart;
            this.announcer = new e2(t3, "polite");
          }
          onChartUpdate() {
            let t3 = this.chart, e3 = this, i3 = t3.rangeSelector;
            i3 && (this.updateSelectorVisibility(), this.setDropdownAttrs(), i3.buttons && i3.buttons.length && i3.buttons.forEach((t4) => {
              e3.setRangeButtonAttrs(t4);
            }), i3.maxInput && i3.minInput && ["minInput", "maxInput"].forEach(function(s2, n2) {
              let o2 = i3[s2];
              o2 && (a(t3, o2), e3.setRangeInputAttrs(o2, "accessibility.rangeSelector." + (n2 ? "max" : "min") + "InputLabel"));
            }));
          }
          updateSelectorVisibility() {
            let t3 = this.chart, e3 = t3.rangeSelector, i3 = e3 && e3.dropdown, s2 = e3 && e3.buttons || [], n2 = (t4) => t4.setAttribute("aria-hidden", true);
            e3 && e3.hasVisibleDropdown && i3 ? (a(t3, i3), s2.forEach((t4) => n2(t4.element))) : (i3 && n2(i3), s2.forEach((e4) => a(t3, e4.element)));
          }
          setDropdownAttrs() {
            let t3 = this.chart, e3 = t3.rangeSelector && t3.rangeSelector.dropdown;
            if (e3) {
              let i3 = t3.langFormat("accessibility.rangeSelector.dropdownLabel", { rangeTitle: t3.options.lang.rangeSelectorZoom });
              e3.setAttribute("aria-label", i3), e3.setAttribute("tabindex", -1);
            }
          }
          setRangeButtonAttrs(t3) {
            d(t3.element, { tabindex: -1, role: "button" });
          }
          setRangeInputAttrs(t3, e3) {
            let i3 = this.chart;
            d(t3, { tabindex: -1, "aria-label": i3.langFormat(e3, { chart: i3 }) });
          }
          onButtonNavKbdArrowKey(t3, e3) {
            let i3 = t3.response, s2 = this.keyCodes, n2 = this.chart, o2 = n2.options.accessibility.keyboardNavigation.wrapAround, r2 = e3 === s2.left || e3 === s2.up ? -1 : 1, a2 = n2.highlightRangeSelectorButton(n2.highlightedRangeSelectorItemIx + r2);
            return a2 ? i3.success : o2 ? (t3.init(r2), i3.success) : i3[r2 > 0 ? "next" : "prev"];
          }
          onButtonNavKbdClick(t3) {
            let e3 = t3.response, i3 = this.chart, s2 = 3 === i3.oldRangeSelectorItemState;
            return s2 || this.fakeClickEvent(i3.rangeSelector.buttons[i3.highlightedRangeSelectorItemIx].element), e3.success;
          }
          onAfterBtnClick() {
            let t3 = this.chart, e3 = l(t3.xAxis[0]), i3 = t3.langFormat("accessibility.rangeSelector.clickButtonAnnouncement", { chart: t3, axisRangeDescription: e3 });
            i3 && this.announcer.announce(i3);
          }
          onInputKbdMove(t3) {
            let e3 = this.chart, i3 = e3.rangeSelector, s2 = e3.highlightedInputRangeIx = (e3.highlightedInputRangeIx || 0) + t3;
            if (s2 > 1 || s2 < 0) {
              if (e3.accessibility)
                return e3.accessibility.keyboardNavigation.exiting = true, e3.accessibility.keyboardNavigation.tabindexContainer.focus(), e3.accessibility.keyboardNavigation.move(t3);
            } else if (i3) {
              let t4 = i3[s2 ? "maxDateBox" : "minDateBox"], n2 = i3[s2 ? "maxInput" : "minInput"];
              t4 && n2 && e3.setFocusToElement(t4, n2);
            }
            return true;
          }
          onInputNavInit(t3) {
            let e3 = this, i3 = this.chart, s2 = t3 > 0 ? 0 : 1, n2 = i3.rangeSelector, o2 = n2 && n2[s2 ? "maxDateBox" : "minDateBox"], r2 = n2 && n2.minInput, a2 = n2 && n2.maxInput, l2 = s2 ? a2 : r2;
            if (i3.highlightedInputRangeIx = s2, o2 && r2 && a2) {
              i3.setFocusToElement(o2, l2), this.removeInputKeydownHandler && this.removeInputKeydownHandler();
              let t4 = (t5) => {
                let i4 = (t5.which || t5.keyCode) === this.keyCodes.tab;
                i4 && e3.onInputKbdMove(t5.shiftKey ? -1 : 1) && (t5.preventDefault(), t5.stopPropagation());
              }, s3 = c(r2, "keydown", t4), n3 = c(a2, "keydown", t4);
              this.removeInputKeydownHandler = () => {
                s3(), n3();
              };
            }
          }
          onInputNavTerminate() {
            let t3 = this.chart.rangeSelector || {};
            t3.maxInput && t3.hideInput("max"), t3.minInput && t3.hideInput("min"), this.removeInputKeydownHandler && (this.removeInputKeydownHandler(), delete this.removeInputKeydownHandler);
          }
          initDropdownNav() {
            let t3 = this.chart, e3 = t3.rangeSelector, i3 = e3 && e3.dropdown;
            e3 && i3 && (t3.setFocusToElement(e3.buttonGroup, i3), this.removeDropdownKeydownHandler && this.removeDropdownKeydownHandler(), this.removeDropdownKeydownHandler = c(i3, "keydown", (e4) => {
              let i4 = (e4.which || e4.keyCode) === this.keyCodes.tab, s2 = t3.accessibility;
              i4 && (e4.preventDefault(), e4.stopPropagation(), s2 && (s2.keyboardNavigation.tabindexContainer.focus(), s2.keyboardNavigation.move(e4.shiftKey ? -1 : 1)));
            }));
          }
          getRangeSelectorButtonNavigation() {
            let t3 = this.chart, e3 = this.keyCodes, i3 = this;
            return new n(t3, { keyCodeMap: [[[e3.left, e3.right, e3.up, e3.down], function(t4) {
              return i3.onButtonNavKbdArrowKey(this, t4);
            }], [[e3.enter, e3.space], function() {
              return i3.onButtonNavKbdClick(this);
            }]], validate: function() {
              return !!(t3.rangeSelector && t3.rangeSelector.buttons && t3.rangeSelector.buttons.length);
            }, init: function(e4) {
              let s2 = t3.rangeSelector;
              if (s2 && s2.hasVisibleDropdown)
                i3.initDropdownNav();
              else if (s2) {
                let i4 = s2.buttons.length - 1;
                t3.highlightRangeSelectorButton(e4 > 0 ? 0 : i4);
              }
            }, terminate: function() {
              i3.removeDropdownKeydownHandler && (i3.removeDropdownKeydownHandler(), delete i3.removeDropdownKeydownHandler);
            } });
          }
          getRangeSelectorInputNavigation() {
            let t3 = this.chart, e3 = this;
            return new n(t3, { keyCodeMap: [], validate: function() {
              return !!(t3.rangeSelector && t3.rangeSelector.inputGroup && "hidden" !== t3.rangeSelector.inputGroup.element.style.visibility && false !== t3.options.rangeSelector.inputEnabled && t3.rangeSelector.minInput && t3.rangeSelector.maxInput);
            }, init: function(t4) {
              e3.onInputNavInit(t4);
            }, terminate: function() {
              e3.onInputNavTerminate();
            } });
          }
          getKeyboardNavigation() {
            return [this.getRangeSelectorButtonNavigation(), this.getRangeSelectorInputNavigation()];
          }
          destroy() {
            this.removeDropdownKeydownHandler && this.removeDropdownKeydownHandler(), this.removeInputKeydownHandler && this.removeInputKeydownHandler(), this.announcer && this.announcer.destroy();
          }
        }
        return function(t3) {
          function e3(t4) {
            let e4 = this.rangeSelector && this.rangeSelector.buttons || [], i4 = this.highlightedRangeSelectorItemIx, s2 = this.rangeSelector && this.rangeSelector.selected;
            return void 0 !== i4 && e4[i4] && i4 !== s2 && e4[i4].setState(this.oldRangeSelectorItemState || 0), this.highlightedRangeSelectorItemIx = t4, !!e4[t4] && (this.setFocusToElement(e4[t4].box, e4[t4].element), t4 !== s2 && (this.oldRangeSelectorItemState = e4[t4].state, e4[t4].setState(1)), true);
          }
          function i3() {
            let t4 = this.chart.accessibility;
            if (t4 && t4.components.rangeSelector)
              return t4.components.rangeSelector.onAfterBtnClick();
          }
          t3.compose = function t4(s2, n2) {
            if (u(h, t4)) {
              let t5 = s2.prototype;
              t5.highlightRangeSelectorButton = e3, c(o, "afterBtnClick", i3);
            }
          };
        }(p || (p = {})), p;
      }), i(e, "Accessibility/Components/SeriesComponent/ForcedMarkers.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var i2;
        let { composed: s } = t2, { addEvent: n, merge: o, pushUnique: r } = e2;
        return function(t3) {
          function e3(t4) {
            o(true, t4, { marker: { enabled: true, states: { normal: { opacity: 0 } } } });
          }
          function i3(t4) {
            return t4.marker.states && t4.marker.states.normal && t4.marker.states.normal.opacity;
          }
          function a(t4) {
            return !!(t4._hasPointMarkers && t4.points && t4.points.length);
          }
          function l() {
            this.chart.styledMode && (this.markerGroup && this.markerGroup[this.a11yMarkersForced ? "addClass" : "removeClass"]("highcharts-a11y-markers-hidden"), a(this) && this.points.forEach((t4) => {
              t4.graphic && (t4.graphic[t4.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-hidden"), t4.graphic[false === t4.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-visible"));
            }));
          }
          function h(t4) {
            this.resetA11yMarkerOptions = o(t4.options.marker || {}, this.userOptions.marker || {});
          }
          function c() {
            let t4 = this.options;
            (function(t5) {
              let e4 = t5.chart, i4 = e4.options.accessibility.enabled, s2 = false !== (t5.options.accessibility && t5.options.accessibility.enabled);
              return i4 && s2 && function(t6) {
                let e5 = t6.chart.options.accessibility;
                return t6.points.length < e5.series.pointDescriptionEnabledThreshold || false === e5.series.pointDescriptionEnabledThreshold;
              }(t5);
            })(this) ? (t4.marker && false === t4.marker.enabled && (this.a11yMarkersForced = true, e3(this.options)), a(this) && function(t5) {
              let s2 = t5.points.length;
              for (; s2--; ) {
                let n2 = t5.points[s2], r2 = n2.options, a2 = n2.hasForcedA11yMarker;
                if (delete n2.hasForcedA11yMarker, r2.marker) {
                  let t6 = a2 && 0 === i3(r2);
                  r2.marker.enabled && !t6 ? (o(true, r2.marker, { states: { normal: { opacity: i3(r2) || 1 } } }), n2.hasForcedA11yMarker = false) : false === r2.marker.enabled && (e3(r2), n2.hasForcedA11yMarker = true);
                }
              }
            }(this)) : this.a11yMarkersForced && (delete this.a11yMarkersForced, function(t5) {
              let e4 = t5.resetA11yMarkerOptions;
              if (e4) {
                let i4 = e4.states && e4.states.normal && e4.states.normal.opacity;
                t5.userOptions && t5.userOptions.marker && (t5.userOptions.marker.enabled = true), t5.update({ marker: { enabled: e4.enabled, states: { normal: { opacity: i4 } } } });
              }
            }(this), delete this.resetA11yMarkerOptions);
          }
          t3.compose = function t4(e4) {
            r(s, t4) && (n(e4, "afterSetOptions", h), n(e4, "render", c), n(e4, "afterRender", l));
          };
        }(i2 || (i2 = {})), i2;
      }), i(e, "Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js", [e["Core/Series/Point.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Globals.js"], e["Core/Utilities.js"], e["Accessibility/KeyboardNavigationHandler.js"], e["Accessibility/Utils/EventProvider.js"], e["Accessibility/Utils/ChartUtilities.js"]], function(t2, e2, i2, s, n, o, r, a) {
        let { seriesTypes: l } = i2, { composed: h, doc: c } = s, { defined: d, fireEvent: u, pushUnique: p } = n, { getPointFromXY: g, getSeriesFromName: m, scrollAxisToPoint: b } = a;
        function f(t3) {
          let e3 = t3.index, i3 = t3.series.points, s2 = i3.length;
          if (i3[e3] === t3)
            return e3;
          for (; s2--; )
            if (i3[s2] === t3)
              return s2;
        }
        function x(t3) {
          let e3 = t3.chart.options.accessibility, i3 = e3.keyboardNavigation.seriesNavigation, s2 = t3.options.accessibility || {}, n2 = s2.keyboardNavigation;
          return n2 && false === n2.enabled || false === s2.enabled || false === t3.options.enableMouseTracking || !t3.visible || i3.pointNavigationEnabledThreshold && +i3.pointNavigationEnabledThreshold <= t3.points.length;
        }
        function y(t3) {
          let e3 = t3.series.chart.options.accessibility, i3 = t3.options.accessibility && false === t3.options.accessibility.enabled;
          return t3.isNull && e3.keyboardNavigation.seriesNavigation.skipNullPoints || false === t3.visible || false === t3.isInside || i3 || x(t3.series);
        }
        function v(t3) {
          let e3 = t3.series || [], i3 = e3.length;
          for (let t4 = 0; t4 < i3; ++t4)
            if (!x(e3[t4])) {
              let i4 = function(t5) {
                let e4 = t5.points || [], i5 = e4.length;
                for (let t6 = 0; t6 < i5; ++t6)
                  if (!y(e4[t6]))
                    return e4[t6];
                return null;
              }(e3[t4]);
              if (i4)
                return i4;
            }
          return null;
        }
        function A(t3) {
          let e3 = t3.series.length, i3 = e3, s2 = false;
          for (; i3-- && (t3.highlightedPoint = t3.series[i3].points[t3.series[i3].points.length - 1], !(s2 = t3.series[i3].highlightNextValidPoint())); )
            ;
          return s2;
        }
        function w(t3) {
          delete t3.highlightedPoint;
          let e3 = v(t3);
          return !!e3 && e3.highlight();
        }
        class C {
          constructor(t3, e3) {
            this.keyCodes = e3, this.chart = t3;
          }
          init() {
            let i3 = this, s2 = this.chart, n2 = this.eventProvider = new r();
            n2.addEvent(e2, "destroy", function() {
              return i3.onSeriesDestroy(this);
            }), n2.addEvent(s2, "afterApplyDrilldown", function() {
              !function(t3) {
                let e3 = v(t3);
                e3 && e3.highlight(false);
              }(this);
            }), n2.addEvent(s2, "drilldown", function(t3) {
              let e3 = t3.point, s3 = e3.series;
              i3.lastDrilledDownPoint = { x: e3.x, y: e3.y, seriesName: s3 ? s3.name : "" };
            }), n2.addEvent(s2, "drillupall", function() {
              setTimeout(function() {
                i3.onDrillupAll();
              }, 10);
            }), n2.addEvent(t2, "afterSetState", function() {
              let t3 = this.graphic && this.graphic.element, e3 = c.activeElement, i4 = e3 && e3.getAttribute("class"), n3 = i4 && i4.indexOf("highcharts-a11y-proxy-element") > -1;
              s2.highlightedPoint === this && e3 !== t3 && !n3 && t3 && t3.focus && t3.focus();
            });
          }
          onDrillupAll() {
            let t3;
            let e3 = this.lastDrilledDownPoint, i3 = this.chart, s2 = e3 && m(i3, e3.seriesName);
            e3 && s2 && d(e3.x) && d(e3.y) && (t3 = g(s2, e3.x, e3.y)), t3 = t3 || v(i3), i3.container && i3.container.focus(), t3 && t3.highlight && t3.highlight(false);
          }
          getKeyboardNavigationHandler() {
            let t3 = this, e3 = this.keyCodes, i3 = this.chart, s2 = i3.inverted;
            return new o(i3, { keyCodeMap: [[s2 ? [e3.up, e3.down] : [e3.left, e3.right], function(e4) {
              return t3.onKbdSideways(this, e4);
            }], [s2 ? [e3.left, e3.right] : [e3.up, e3.down], function(e4) {
              return t3.onKbdVertical(this, e4);
            }], [[e3.enter, e3.space], function(t4, e4) {
              let s3 = i3.highlightedPoint;
              return s3 && (e4.point = s3, u(s3.series, "click", e4), s3.firePointEvent("click")), this.response.success;
            }], [[e3.home], function() {
              return w(i3), this.response.success;
            }], [[e3.end], function() {
              return A(i3), this.response.success;
            }], [[e3.pageDown, e3.pageUp], function(t4) {
              return i3.highlightAdjacentSeries(t4 === e3.pageDown), this.response.success;
            }]], init: function() {
              return t3.onHandlerInit(this);
            }, validate: function() {
              return !!v(i3);
            }, terminate: function() {
              return t3.onHandlerTerminate();
            } });
          }
          onKbdSideways(t3, e3) {
            let i3 = this.keyCodes, s2 = e3 === i3.right || e3 === i3.down;
            return this.attemptHighlightAdjacentPoint(t3, s2);
          }
          onHandlerInit(t3) {
            let e3 = this.chart, i3 = e3.options.accessibility.keyboardNavigation;
            return i3.seriesNavigation.rememberPointFocus && e3.highlightedPoint ? e3.highlightedPoint.highlight() : w(e3), t3.response.success;
          }
          onKbdVertical(t3, e3) {
            let i3 = this.chart, s2 = this.keyCodes, n2 = e3 === s2.down || e3 === s2.right, o2 = i3.options.accessibility.keyboardNavigation.seriesNavigation;
            if (o2.mode && "serialize" === o2.mode)
              return this.attemptHighlightAdjacentPoint(t3, n2);
            let r2 = i3.highlightedPoint && i3.highlightedPoint.series.keyboardMoveVertical ? "highlightAdjacentPointVertical" : "highlightAdjacentSeries";
            return i3[r2](n2), t3.response.success;
          }
          onHandlerTerminate() {
            let t3 = this.chart, e3 = t3.options.accessibility.keyboardNavigation;
            t3.tooltip && t3.tooltip.hide(0);
            let i3 = t3.highlightedPoint && t3.highlightedPoint.series;
            i3 && i3.onMouseOut && i3.onMouseOut(), t3.highlightedPoint && t3.highlightedPoint.onMouseOut && t3.highlightedPoint.onMouseOut(), e3.seriesNavigation.rememberPointFocus || delete t3.highlightedPoint;
          }
          attemptHighlightAdjacentPoint(t3, e3) {
            let i3 = this.chart, s2 = i3.options.accessibility.keyboardNavigation.wrapAround, n2 = i3.highlightAdjacentPoint(e3);
            return n2 ? t3.response.success : s2 && (e3 ? w(i3) : A(i3)) ? t3.response.success : t3.response[e3 ? "next" : "prev"];
          }
          onSeriesDestroy(t3) {
            let e3 = this.chart, i3 = e3.highlightedPoint && e3.highlightedPoint.series === t3;
            i3 && (delete e3.highlightedPoint, e3.focusElement && e3.focusElement.removeFocusBorder());
          }
          destroy() {
            this.eventProvider.removeAddedEvents();
          }
        }
        return function(t3) {
          function e3(t4) {
            let e4, i4;
            let s3 = this.series, n3 = this.highlightedPoint, o3 = n3 && f(n3) || 0, r2 = n3 && n3.series.points || [], a2 = this.series && this.series[this.series.length - 1], l2 = a2 && a2.points && a2.points[a2.points.length - 1];
            if (!s3[0] || !s3[0].points)
              return false;
            if (n3) {
              if (e4 = s3[n3.series.index + (t4 ? 1 : -1)], (i4 = r2[o3 + (t4 ? 1 : -1)]) || !e4 || (i4 = e4.points[t4 ? 0 : e4.points.length - 1]), !i4)
                return false;
            } else
              i4 = t4 ? s3[0].points[0] : l2;
            return y(i4) ? (x(e4 = i4.series) ? this.highlightedPoint = t4 ? e4.points[e4.points.length - 1] : e4.points[0] : this.highlightedPoint = i4, this.highlightAdjacentPoint(t4)) : i4.highlight();
          }
          function i3(t4) {
            let e4 = this.highlightedPoint, i4 = 1 / 0, s3;
            return !!(d(e4.plotX) && d(e4.plotY)) && (this.series.forEach((n3) => {
              x(n3) || n3.points.forEach((o3) => {
                if (!d(o3.plotY) || !d(o3.plotX) || o3 === e4)
                  return;
                let r2 = o3.plotY - e4.plotY, a2 = Math.abs(o3.plotX - e4.plotX), l2 = Math.abs(r2) * Math.abs(r2) + a2 * a2 * 4;
                n3.yAxis && n3.yAxis.reversed && (r2 *= -1), !(r2 <= 0 && t4 || r2 >= 0 && !t4 || l2 < 5 || y(o3)) && l2 < i4 && (i4 = l2, s3 = o3);
              });
            }), !!s3 && s3.highlight());
          }
          function s2(t4) {
            let e4, i4, s3;
            let n3 = this.highlightedPoint, o3 = this.series && this.series[this.series.length - 1], r2 = o3 && o3.points && o3.points[o3.points.length - 1];
            return this.highlightedPoint ? !!((e4 = this.series[n3.series.index + (t4 ? -1 : 1)]) && (i4 = function(t5, e5, i5, s4) {
              let n4 = 1 / 0, o4, r3, a2, l2 = e5.points.length, h2 = (t6) => !(d(t6.plotX) && d(t6.plotY));
              if (!h2(t5)) {
                for (; l2--; )
                  !h2(o4 = e5.points[l2]) && (a2 = (t5.plotX - o4.plotX) * (t5.plotX - o4.plotX) * 4 + (t5.plotY - o4.plotY) * (t5.plotY - o4.plotY) * 1) < n4 && (n4 = a2, r3 = l2);
                return d(r3) ? e5.points[r3] : void 0;
              }
            }(n3, e4, 0))) && (x(e4) ? (i4.highlight(), s3 = this.highlightAdjacentSeries(t4)) ? s3 : (n3.highlight(), false) : (i4.highlight(), i4.series.highlightNextValidPoint())) : (e4 = t4 ? this.series && this.series[0] : o3, !!(i4 = t4 ? e4 && e4.points && e4.points[0] : r2) && i4.highlight());
          }
          function n2(t4 = true) {
            var _a, _b;
            let e4 = this.series.chart, i4 = (_b = (_a = e4.tooltip) == null ? void 0 : _a.label) == null ? void 0 : _b.element;
            !this.isNull && t4 ? this.onMouseOver() : e4.tooltip && e4.tooltip.hide(0), b(this), this.graphic && (e4.setFocusToElement(this.graphic), !t4 && e4.focusElement && e4.focusElement.removeFocusBorder()), e4.highlightedPoint = this;
            let s3 = i4 == null ? void 0 : i4.getBoundingClientRect().top;
            if (i4 && s3 && s3 < 0) {
              let t5 = window.scrollY;
              window.scrollTo({ behavior: "smooth", top: t5 + s3 });
            }
            return this;
          }
          function o2() {
            let t4 = this.chart.highlightedPoint, e4 = (t4 && t4.series) === this ? f(t4) : 0, i4 = this.points, s3 = i4.length;
            if (i4 && s3) {
              for (let t5 = e4; t5 < s3; ++t5)
                if (!y(i4[t5]))
                  return i4[t5].highlight();
              for (let t5 = e4; t5 >= 0; --t5)
                if (!y(i4[t5]))
                  return i4[t5].highlight();
            }
            return false;
          }
          t3.compose = function t4(r2, a2, c2) {
            if (p(h, t4)) {
              let t5 = r2.prototype, h2 = a2.prototype, d2 = c2.prototype;
              t5.highlightAdjacentPoint = e3, t5.highlightAdjacentPointVertical = i3, t5.highlightAdjacentSeries = s2, h2.highlight = n2, d2.keyboardMoveVertical = true, ["column", "gantt", "pie"].forEach((t6) => {
                l[t6] && (l[t6].prototype.keyboardMoveVertical = false);
              }), d2.highlightNextValidPoint = o2;
            }
          };
        }(C || (C = {})), C;
      }), i(e, "Accessibility/Components/SeriesComponent/SeriesComponent.js", [e["Accessibility/AccessibilityComponent.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Accessibility/Components/SeriesComponent/ForcedMarkers.js"], e["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"], e["Accessibility/Components/SeriesComponent/SeriesDescriber.js"], e["Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js"]], function(t2, e2, i2, s, n, o) {
        let { hideSeriesFromAT: r } = e2, { describeSeries: a } = n;
        return class extends t2 {
          static compose(t3, e3, n2) {
            s.compose(n2), i2.compose(n2), o.compose(t3, e3, n2);
          }
          init() {
            this.newDataAnnouncer = new s(this.chart), this.newDataAnnouncer.init(), this.keyboardNavigation = new o(this.chart, this.keyCodes), this.keyboardNavigation.init(), this.hideTooltipFromATWhenShown(), this.hideSeriesLabelsFromATWhenShown();
          }
          hideTooltipFromATWhenShown() {
            let t3 = this;
            this.chart.tooltip && this.addEvent(this.chart.tooltip.constructor, "refresh", function() {
              this.chart === t3.chart && this.label && this.label.element && this.label.element.setAttribute("aria-hidden", true);
            });
          }
          hideSeriesLabelsFromATWhenShown() {
            this.addEvent(this.chart, "afterDrawSeriesLabels", function() {
              this.series.forEach(function(t3) {
                t3.labelBySeries && t3.labelBySeries.attr("aria-hidden", true);
              });
            });
          }
          onChartRender() {
            let t3 = this.chart;
            t3.series.forEach(function(t4) {
              let e3 = false !== (t4.options.accessibility && t4.options.accessibility.enabled) && t4.visible && 0 !== t4.data.length;
              e3 ? a(t4) : r(t4);
            });
          }
          getKeyboardNavigation() {
            return this.keyboardNavigation.getKeyboardNavigationHandler();
          }
          destroy() {
            this.newDataAnnouncer.destroy(), this.keyboardNavigation.destroy();
          }
        };
      }), i(e, "Accessibility/Components/ZoomComponent.js", [e["Accessibility/AccessibilityComponent.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Accessibility/KeyboardNavigationHandler.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, n) {
        let { unhideChartElementFromAT: o } = e2, { getFakeMouseEvent: r } = i2, { attr: a, pick: l } = n;
        return class extends t2 {
          constructor() {
            super(...arguments), this.focusedMapNavButtonIx = -1;
          }
          init() {
            let t3 = this, e3 = this.chart;
            this.proxyProvider.addGroup("zoom", "div"), ["afterShowResetZoom", "afterApplyDrilldown", "drillupall"].forEach((i3) => {
              t3.addEvent(e3, i3, function() {
                t3.updateProxyOverlays();
              });
            });
          }
          onChartUpdate() {
            let t3 = this.chart, e3 = this;
            t3.mapNavigation && t3.mapNavigation.navButtons.forEach((i3, s2) => {
              o(t3, i3.element), e3.setMapNavButtonAttrs(i3.element, "accessibility.zoom.mapZoom" + (s2 ? "Out" : "In"));
            });
          }
          setMapNavButtonAttrs(t3, e3) {
            let i3 = this.chart, s2 = i3.langFormat(e3, { chart: i3 });
            a(t3, { tabindex: -1, role: "button", "aria-label": s2 });
          }
          onChartRender() {
            this.updateProxyOverlays();
          }
          updateProxyOverlays() {
            let t3 = this.chart;
            if (this.proxyProvider.clearGroup("zoom"), t3.resetZoomButton && this.createZoomProxyButton(t3.resetZoomButton, "resetZoomProxyButton", t3.langFormat("accessibility.zoom.resetZoomButton", { chart: t3 })), t3.drillUpButton && t3.breadcrumbs && t3.breadcrumbs.list) {
              let e3 = t3.breadcrumbs.list[t3.breadcrumbs.list.length - 1];
              this.createZoomProxyButton(t3.drillUpButton, "drillUpProxyButton", t3.langFormat("accessibility.drillUpButton", { chart: t3, buttonText: t3.breadcrumbs.getButtonText(e3) }));
            }
          }
          createZoomProxyButton(t3, e3, i3) {
            this[e3] = this.proxyProvider.addProxyElement("zoom", { click: t3 }, "button", { "aria-label": i3, tabindex: -1 });
          }
          getMapZoomNavigation() {
            let t3 = this.keyCodes, e3 = this.chart, i3 = this;
            return new s(e3, { keyCodeMap: [[[t3.up, t3.down, t3.left, t3.right], function(t4) {
              return i3.onMapKbdArrow(this, t4);
            }], [[t3.tab], function(t4, e4) {
              return i3.onMapKbdTab(this, e4);
            }], [[t3.space, t3.enter], function() {
              return i3.onMapKbdClick(this);
            }]], validate: function() {
              return !!(e3.mapView && e3.mapNavigation && e3.mapNavigation.navButtons.length);
            }, init: function(t4) {
              return i3.onMapNavInit(t4);
            } });
          }
          onMapKbdArrow(t3, e3) {
            let i3 = this.chart, s2 = this.keyCodes, n2 = i3.container, o2 = e3 === s2.up || e3 === s2.down, a2 = e3 === s2.left || e3 === s2.up ? 1 : -1, l2 = (o2 ? i3.plotHeight : i3.plotWidth) / 10 * a2, h = 10 * Math.random(), c = { x: n2.offsetLeft + i3.plotLeft + i3.plotWidth / 2 + h, y: n2.offsetTop + i3.plotTop + i3.plotHeight / 2 + h }, d = o2 ? { x: c.x, y: c.y + l2 } : { x: c.x + l2, y: c.y };
            return [r("mousedown", c), r("mousemove", d), r("mouseup", d)].forEach((t4) => n2.dispatchEvent(t4)), t3.response.success;
          }
          onMapKbdTab(t3, e3) {
            let i3 = this.chart, s2 = t3.response, n2 = e3.shiftKey, o2 = n2 && !this.focusedMapNavButtonIx || !n2 && this.focusedMapNavButtonIx;
            if (i3.mapNavigation.navButtons[this.focusedMapNavButtonIx].setState(0), o2)
              return i3.mapView && i3.mapView.zoomBy(), s2[n2 ? "prev" : "next"];
            this.focusedMapNavButtonIx += n2 ? -1 : 1;
            let r2 = i3.mapNavigation.navButtons[this.focusedMapNavButtonIx];
            return i3.setFocusToElement(r2.box, r2.element), r2.setState(2), s2.success;
          }
          onMapKbdClick(t3) {
            let e3 = this.chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].element;
            return this.fakeClickEvent(e3), t3.response.success;
          }
          onMapNavInit(t3) {
            let e3 = this.chart, i3 = e3.mapNavigation.navButtons[0], s2 = e3.mapNavigation.navButtons[1], n2 = t3 > 0 ? i3 : s2;
            e3.setFocusToElement(n2.box, n2.element), n2.setState(2), this.focusedMapNavButtonIx = t3 > 0 ? 0 : 1;
          }
          simpleButtonNavigation(t3, e3, i3) {
            let n2 = this.keyCodes, o2 = this, r2 = this.chart;
            return new s(r2, { keyCodeMap: [[[n2.tab, n2.up, n2.down, n2.left, n2.right], function(t4, e4) {
              let i4 = t4 === n2.tab && e4.shiftKey || t4 === n2.left || t4 === n2.up;
              return this.response[i4 ? "prev" : "next"];
            }], [[n2.space, n2.enter], function() {
              let t4 = i3(this, r2);
              return l(t4, this.response.success);
            }]], validate: function() {
              let i4 = r2[t3] && r2[t3].box && o2[e3].innerElement;
              return i4;
            }, init: function() {
              r2.setFocusToElement(r2[t3].box, o2[e3].innerElement);
            } });
          }
          getKeyboardNavigation() {
            return [this.simpleButtonNavigation("resetZoomButton", "resetZoomProxyButton", function(t3, e3) {
              e3.zoomOut();
            }), this.simpleButtonNavigation("drillUpButton", "drillUpProxyButton", function(t3, e3) {
              return e3.drillUp(), t3.response.prev;
            }), this.getMapZoomNavigation()];
          }
        };
      }), i(e, "Accessibility/HighContrastMode.js", [e["Core/Globals.js"]], function(t2) {
        let { doc: e2, isMS: i2, win: s } = t2;
        return { isHighContrastModeActive: function() {
          let t3 = /(Edg)/.test(s.navigator.userAgent);
          if (s.matchMedia && t3)
            return s.matchMedia("(-ms-high-contrast: active)").matches;
          if (i2 && s.getComputedStyle) {
            let t4 = e2.createElement("div");
            t4.style.backgroundImage = "url(data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==)", e2.body.appendChild(t4);
            let i3 = (t4.currentStyle || s.getComputedStyle(t4)).backgroundImage;
            return e2.body.removeChild(t4), "none" === i3;
          }
          return s.matchMedia && s.matchMedia("(forced-colors: active)").matches;
        }, setHighContrastTheme: function(t3) {
          t3.highContrastModeActive = true;
          let e3 = t3.options.accessibility.highContrastTheme;
          t3.update(e3, false), t3.series.forEach(function(t4) {
            let i3 = e3.plotOptions[t4.type] || {};
            t4.update({ color: i3.color || "windowText", colors: [i3.color || "windowText"], borderColor: i3.borderColor || "window" }), t4.points.forEach(function(t5) {
              t5.options && t5.options.color && t5.update({ color: i3.color || "windowText", borderColor: i3.borderColor || "window" }, false);
            });
          }), t3.redraw();
        } };
      }), i(e, "Accessibility/HighContrastTheme.js", [], function() {
        return { chart: { backgroundColor: "window" }, title: { style: { color: "windowText" } }, subtitle: { style: { color: "windowText" } }, colorAxis: { minColor: "windowText", maxColor: "windowText", stops: [] }, colors: ["windowText"], xAxis: { gridLineColor: "windowText", labels: { style: { color: "windowText" } }, lineColor: "windowText", minorGridLineColor: "windowText", tickColor: "windowText", title: { style: { color: "windowText" } } }, yAxis: { gridLineColor: "windowText", labels: { style: { color: "windowText" } }, lineColor: "windowText", minorGridLineColor: "windowText", tickColor: "windowText", title: { style: { color: "windowText" } } }, tooltip: { backgroundColor: "window", borderColor: "windowText", style: { color: "windowText" } }, plotOptions: { series: { lineColor: "windowText", fillColor: "window", borderColor: "windowText", edgeColor: "windowText", borderWidth: 1, dataLabels: { connectorColor: "windowText", color: "windowText", style: { color: "windowText", textOutline: "none" } }, marker: { lineColor: "windowText", fillColor: "windowText" } }, pie: { color: "window", colors: ["window"], borderColor: "windowText", borderWidth: 1 }, boxplot: { fillColor: "window" }, candlestick: { lineColor: "windowText", fillColor: "window" }, errorbar: { fillColor: "window" } }, legend: { backgroundColor: "window", itemStyle: { color: "windowText" }, itemHoverStyle: { color: "windowText" }, itemHiddenStyle: { color: "#555" }, title: { style: { color: "windowText" } } }, credits: { style: { color: "windowText" } }, drilldown: { activeAxisLabelStyle: { color: "windowText" }, activeDataLabelStyle: { color: "windowText" } }, navigation: { buttonOptions: { symbolStroke: "windowText", theme: { fill: "window" } } }, rangeSelector: { buttonTheme: { fill: "window", stroke: "windowText", style: { color: "windowText" }, states: { hover: { fill: "window", stroke: "windowText", style: { color: "windowText" } }, select: { fill: "#444", stroke: "windowText", style: { color: "windowText" } } } }, inputBoxBorderColor: "windowText", inputStyle: { backgroundColor: "window", color: "windowText" }, labelStyle: { color: "windowText" } }, navigator: { handles: { backgroundColor: "window", borderColor: "windowText" }, outlineColor: "windowText", maskFill: "transparent", series: { color: "windowText", lineColor: "windowText" }, xAxis: { gridLineColor: "windowText" } }, scrollbar: { barBackgroundColor: "#444", barBorderColor: "windowText", buttonArrowColor: "windowText", buttonBackgroundColor: "window", buttonBorderColor: "windowText", rifleColor: "windowText", trackBackgroundColor: "window", trackBorderColor: "windowText" } };
      }), i(e, "Accessibility/Options/A11yDefaults.js", [], function() {
        return { accessibility: { enabled: true, screenReaderSection: { beforeChartFormat: "<{headingTagName}>{chartTitle}</{headingTagName}><div>{typeDescription}</div><div>{chartSubtitle}</div><div>{chartLongdesc}</div><div>{playAsSoundButton}</div><div>{viewTableButton}</div><div>{xAxisDescription}</div><div>{yAxisDescription}</div><div>{annotationsTitle}{annotationsList}</div>", afterChartFormat: "{endOfChartMarker}", axisRangeDateFormat: "%Y-%m-%d %H:%M:%S" }, series: { descriptionFormat: "{seriesDescription}{authorDescription}{axisDescription}", describeSingleSeries: false, pointDescriptionEnabledThreshold: 200 }, point: { valueDescriptionFormat: "{xDescription}{separator}{value}.", describeNull: true }, landmarkVerbosity: "all", linkedDescription: '*[data-highcharts-chart="{index}"] + .highcharts-description', keyboardNavigation: { enabled: true, focusBorder: { enabled: true, hideBrowserFocusOutline: true, style: { color: "#334eff", lineWidth: 2, borderRadius: 3 }, margin: 2 }, order: ["series", "zoom", "rangeSelector", "navigator", "legend", "chartMenu"], wrapAround: true, seriesNavigation: { skipNullPoints: true, pointNavigationEnabledThreshold: false, rememberPointFocus: false } }, announceNewData: { enabled: false, minAnnounceInterval: 5e3, interruptUser: false } }, legend: { accessibility: { enabled: true, keyboardNavigation: { enabled: true } } }, exporting: { accessibility: { enabled: true } }, navigator: { accessibility: { enabled: true } } };
      }), i(e, "Accessibility/Options/LangDefaults.js", [], function() {
        return { accessibility: { defaultChartTitle: "Chart", chartContainerLabel: "{title}. Highcharts interactive chart.", svgContainerLabel: "Interactive chart", drillUpButton: "{buttonText}", credits: "Chart credits: {creditsStr}", thousandsSep: ",", svgContainerTitle: "", graphicContainerLabel: "", screenReaderSection: { beforeRegionLabel: "", afterRegionLabel: "", annotations: { heading: "Chart annotations summary", descriptionSinglePoint: "{annotationText}. Related to {annotationPoint}", descriptionMultiplePoints: "{annotationText}. Related to {annotationPoint}{#each additionalAnnotationPoints}, also related to {this}{/each}", descriptionNoPoints: "{annotationText}" }, endOfChartMarker: "End of interactive chart." }, sonification: { playAsSoundButtonText: "Play as sound, {chartTitle}", playAsSoundClickAnnouncement: "Play" }, legend: { legendLabelNoTitle: "Toggle series visibility, {chartTitle}", legendLabel: "Chart legend: {legendTitle}", legendItem: "Show {itemName}" }, zoom: { mapZoomIn: "Zoom chart", mapZoomOut: "Zoom out chart", resetZoomButton: "Reset zoom" }, rangeSelector: { dropdownLabel: "{rangeTitle}", minInputLabel: "Select start date.", maxInputLabel: "Select end date.", clickButtonAnnouncement: "Viewing {axisRangeDescription}" }, navigator: { handleLabel: "{#eq handleIx 0}Start, percent{else}End, percent{/eq}", groupLabel: "Axis zoom", changeAnnouncement: "{axisRangeDescription}" }, table: { viewAsDataTableButtonText: "View as data table, {chartTitle}", tableSummary: "Table representation of chart." }, announceNewData: { newDataAnnounce: "Updated data for chart {chartTitle}", newSeriesAnnounceSingle: "New data series: {seriesDesc}", newPointAnnounceSingle: "New data point: {pointDesc}", newSeriesAnnounceMultiple: "New data series in chart {chartTitle}: {seriesDesc}", newPointAnnounceMultiple: "New data point in chart {chartTitle}: {pointDesc}" }, seriesTypeDescriptions: { boxplot: "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.", arearange: "Arearange charts are line charts displaying a range between a lower and higher value for each point.", areasplinerange: "These charts are line charts displaying a range between a lower and higher value for each point.", bubble: "Bubble charts are scatter charts where each data point also has a size value.", columnrange: "Columnrange charts are column charts displaying a range between a lower and higher value for each point.", errorbar: "Errorbar series are used to display the variability of the data.", funnel: "Funnel charts are used to display reduction of data in stages.", pyramid: "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.", waterfall: "A waterfall chart is a column chart where each column contributes towards a total end value." }, chartTypes: { emptyChart: "Empty chart", mapTypeDescription: "Map of {mapTitle} with {numSeries} data series.", unknownMap: "Map of unspecified region with {numSeries} data series.", combinationChart: "Combination chart with {numSeries} data series.", defaultSingle: "Chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.", defaultMultiple: "Chart with {numSeries} data series.", splineSingle: "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.", splineMultiple: "Line chart with {numSeries} lines.", lineSingle: "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.", lineMultiple: "Line chart with {numSeries} lines.", columnSingle: "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.", columnMultiple: "Bar chart with {numSeries} data series.", barSingle: "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.", barMultiple: "Bar chart with {numSeries} data series.", pieSingle: "Pie chart with {numPoints} {#eq numPoints 1}slice{else}slices{/eq}.", pieMultiple: "Pie chart with {numSeries} pies.", scatterSingle: "Scatter chart with {numPoints} {#eq numPoints 1}point{else}points{/eq}.", scatterMultiple: "Scatter chart with {numSeries} data series.", boxplotSingle: "Boxplot with {numPoints} {#eq numPoints 1}box{else}boxes{/eq}.", boxplotMultiple: "Boxplot with {numSeries} data series.", bubbleSingle: "Bubble chart with {numPoints} {#eq numPoints 1}bubbles{else}bubble{/eq}.", bubbleMultiple: "Bubble chart with {numSeries} data series." }, axis: { xAxisDescriptionSingular: "The chart has 1 X axis displaying {names[0]}. {ranges[0]}", xAxisDescriptionPlural: "The chart has {numAxes} X axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.", yAxisDescriptionSingular: "The chart has 1 Y axis displaying {names[0]}. {ranges[0]}", yAxisDescriptionPlural: "The chart has {numAxes} Y axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.", timeRangeDays: "Data range: {range} days.", timeRangeHours: "Data range: {range} hours.", timeRangeMinutes: "Data range: {range} minutes.", timeRangeSeconds: "Data range: {range} seconds.", rangeFromTo: "Data ranges from {rangeFrom} to {rangeTo}.", rangeCategories: "Data range: {numCategories} categories." }, exporting: { chartMenuLabel: "Chart menu", menuButtonLabel: "View chart menu, {chartTitle}" }, series: { summary: { default: "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.", defaultCombination: "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.", line: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.", lineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.", spline: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.", splineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.", column: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.", columnCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.", bar: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.", barCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.", pie: "{series.name}, pie {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.", pieCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Pie with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.", scatter: "{series.name}, scatter plot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.", scatterCombination: "{series.name}, series {seriesNumber} of {chart.series.length}, scatter plot with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.", boxplot: "{series.name}, boxplot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.", boxplotCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Boxplot with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.", bubble: "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.", bubbleCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.", map: "{series.name}, map {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.", mapCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Map with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.", mapline: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.", maplineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.", mapbubble: "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.", mapbubbleCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}." }, description: "{description}", xAxisDescription: "X axis, {name}", yAxisDescription: "Y axis, {name}", nullPointValue: "No value", pointAnnotationsDescription: "{#each annotations}Annotation: {this}{/each}" } } };
      }), i(e, "Accessibility/Options/DeprecatedOptions.js", [e["Core/Utilities.js"]], function(t2) {
        let { error: e2, pick: i2 } = t2;
        function s(t3, e3, s2) {
          let n2 = t3, o, r = 0;
          for (; r < e3.length - 1; ++r)
            n2 = n2[o = e3[r]] = i2(n2[o], {});
          n2[e3[e3.length - 1]] = s2;
        }
        function n(t3, i3, n2, o) {
          function r(t4, e3) {
            return e3.reduce(function(t5, e4) {
              return t5[e4];
            }, t4);
          }
          let a = r(t3.options, i3), l = r(t3.options, n2);
          Object.keys(o).forEach(function(r2) {
            let h = a[r2];
            void 0 !== h && (s(l, o[r2], h), e2(32, false, t3, { [i3.join(".") + "." + r2]: n2.join(".") + "." + o[r2].join(".") }));
          });
        }
        return function(t3) {
          (function(t4) {
            let i3 = t4.options.chart, s2 = t4.options.accessibility || {};
            ["description", "typeDescription"].forEach(function(n2) {
              i3[n2] && (s2[n2] = i3[n2], e2(32, false, t4, { [`chart.${n2}`]: `use accessibility.${n2}` }));
            });
          })(t3), function(t4) {
            t4.axes.forEach(function(i3) {
              let s2 = i3.options;
              s2 && s2.description && (s2.accessibility = s2.accessibility || {}, s2.accessibility.description = s2.description, e2(32, false, t4, { "axis.description": "use axis.accessibility.description" }));
            });
          }(t3), t3.series && function(t4) {
            let i3 = { description: ["accessibility", "description"], exposeElementToA11y: ["accessibility", "exposeAsGroupOnly"], pointDescriptionFormatter: ["accessibility", "point", "descriptionFormatter"], skipKeyboardNavigation: ["accessibility", "keyboardNavigation", "enabled"], "accessibility.pointDescriptionFormatter": ["accessibility", "point", "descriptionFormatter"] };
            t4.series.forEach(function(n2) {
              Object.keys(i3).forEach(function(o) {
                let r = n2.options[o];
                "accessibility.pointDescriptionFormatter" === o && (r = n2.options.accessibility && n2.options.accessibility.pointDescriptionFormatter), void 0 !== r && (s(n2.options, i3[o], "skipKeyboardNavigation" === o ? !r : r), e2(32, false, t4, { [`series.${o}`]: "series." + i3[o].join(".") }));
              });
            });
          }(t3), n(t3, ["accessibility"], ["accessibility"], { pointDateFormat: ["point", "dateFormat"], pointDateFormatter: ["point", "dateFormatter"], pointDescriptionFormatter: ["point", "descriptionFormatter"], pointDescriptionThreshold: ["series", "pointDescriptionEnabledThreshold"], pointNavigationThreshold: ["keyboardNavigation", "seriesNavigation", "pointNavigationEnabledThreshold"], pointValueDecimals: ["point", "valueDecimals"], pointValuePrefix: ["point", "valuePrefix"], pointValueSuffix: ["point", "valueSuffix"], screenReaderSectionFormatter: ["screenReaderSection", "beforeChartFormatter"], describeSingleSeries: ["series", "describeSingleSeries"], seriesDescriptionFormatter: ["series", "descriptionFormatter"], onTableAnchorClick: ["screenReaderSection", "onViewDataTableClick"], axisRangeDateFormat: ["screenReaderSection", "axisRangeDateFormat"] }), n(t3, ["accessibility", "keyboardNavigation"], ["accessibility", "keyboardNavigation", "seriesNavigation"], { skipNullPoints: ["skipNullPoints"], mode: ["mode"] }), n(t3, ["lang", "accessibility"], ["lang", "accessibility"], { legendItem: ["legend", "legendItem"], legendLabel: ["legend", "legendLabel"], mapZoomIn: ["zoom", "mapZoomIn"], mapZoomOut: ["zoom", "mapZoomOut"], resetZoomButton: ["zoom", "resetZoomButton"], screenReaderRegionLabel: ["screenReaderSection", "beforeRegionLabel"], rangeSelectorButton: ["rangeSelector", "buttonText"], rangeSelectorMaxInput: ["rangeSelector", "maxInputLabel"], rangeSelectorMinInput: ["rangeSelector", "minInputLabel"], svgContainerEnd: ["screenReaderSection", "endOfChartMarker"], viewAsDataTable: ["table", "viewAsDataTableButtonText"], tableSummary: ["table", "tableSummary"] });
        };
      }), i(e, "Accessibility/Accessibility.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Utilities.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Accessibility/A11yI18n.js"], e["Accessibility/Components/ContainerComponent.js"], e["Accessibility/FocusBorder.js"], e["Accessibility/Components/InfoRegionsComponent.js"], e["Accessibility/KeyboardNavigation.js"], e["Accessibility/Components/LegendComponent.js"], e["Accessibility/Components/MenuComponent.js"], e["Accessibility/Components/NavigatorComponent.js"], e["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"], e["Accessibility/ProxyProvider.js"], e["Accessibility/Components/RangeSelectorComponent.js"], e["Accessibility/Components/SeriesComponent/SeriesComponent.js"], e["Accessibility/Components/ZoomComponent.js"], e["Accessibility/HighContrastMode.js"], e["Accessibility/HighContrastTheme.js"], e["Accessibility/Options/A11yDefaults.js"], e["Accessibility/Options/LangDefaults.js"], e["Accessibility/Options/DeprecatedOptions.js"]], function(t2, e2, i2, s, n, o, r, a, l, h, c, d, u, p, g, m, b, f, x, y, v, A) {
        let { defaultOptions: w } = t2, { composed: C, doc: E } = e2, { addEvent: T, extend: M, fireEvent: S, merge: k, pushUnique: P } = i2, { removeElement: B } = s;
        class D {
          constructor(t3) {
            this.init(t3);
          }
          init(t3) {
            if (this.chart = t3, !E.addEventListener) {
              this.zombie = true, this.components = {}, t3.renderTo.setAttribute("aria-hidden", true);
              return;
            }
            A(t3), this.proxyProvider = new p(this.chart), this.initComponents(), this.keyboardNavigation = new l(t3, this.components);
          }
          initComponents() {
            let t3 = this.chart, e3 = this.proxyProvider, i3 = t3.options.accessibility;
            this.components = { container: new o(), infoRegions: new a(), legend: new h(), chartMenu: new c(), rangeSelector: new g(), series: new m(), zoom: new b(), navigator: new d() }, i3.customComponents && M(this.components, i3.customComponents);
            let s2 = this.components;
            this.getComponentOrder().forEach(function(i4) {
              s2[i4].initBase(t3, e3), s2[i4].init();
            });
          }
          getComponentOrder() {
            if (!this.components)
              return [];
            if (!this.components.series)
              return Object.keys(this.components);
            let t3 = Object.keys(this.components).filter((t4) => "series" !== t4);
            return ["series"].concat(t3);
          }
          update() {
            let t3 = this.components, e3 = this.chart, i3 = e3.options.accessibility;
            S(e3, "beforeA11yUpdate"), e3.types = this.getChartTypes();
            let s2 = i3.keyboardNavigation.order;
            this.proxyProvider.updateGroupOrder(s2), this.getComponentOrder().forEach(function(i4) {
              t3[i4].onChartUpdate(), S(e3, "afterA11yComponentUpdate", { name: i4, component: t3[i4] });
            }), this.keyboardNavigation.update(s2), !e3.highContrastModeActive && f.isHighContrastModeActive() && f.setHighContrastTheme(e3), S(e3, "afterA11yUpdate", { accessibility: this });
          }
          destroy() {
            let t3 = this.chart || {}, e3 = this.components;
            Object.keys(e3).forEach(function(t4) {
              e3[t4].destroy(), e3[t4].destroyBase();
            }), this.proxyProvider && this.proxyProvider.destroy(), t3.announcerContainer && B(t3.announcerContainer), this.keyboardNavigation && this.keyboardNavigation.destroy(), t3.renderTo && t3.renderTo.setAttribute("aria-hidden", true), t3.focusElement && t3.focusElement.removeFocusBorder();
          }
          getChartTypes() {
            let t3 = {};
            return this.chart.series.forEach(function(e3) {
              t3[e3.type] = 1;
            }), Object.keys(t3);
          }
        }
        return function(t3) {
          function e3() {
            this.accessibility && this.accessibility.destroy();
          }
          function i3() {
            this.a11yDirty && this.renderTo && (delete this.a11yDirty, this.updateA11yEnabled());
            let t4 = this.accessibility;
            t4 && !t4.zombie && (t4.proxyProvider.updateProxyElementPositions(), t4.getComponentOrder().forEach(function(e4) {
              t4.components[e4].onChartRender();
            }));
          }
          function s2(t4) {
            let e4 = t4.options.accessibility;
            e4 && (e4.customComponents && (this.options.accessibility.customComponents = e4.customComponents, delete e4.customComponents), k(true, this.options.accessibility, e4), this.accessibility && this.accessibility.destroy && (this.accessibility.destroy(), delete this.accessibility)), this.a11yDirty = true;
          }
          function o2() {
            let e4 = this.accessibility, i4 = this.options.accessibility;
            i4 && i4.enabled ? e4 && !e4.zombie ? e4.update() : (this.accessibility = e4 = new t3(this), e4 && !e4.zombie && e4.update()) : e4 ? (e4.destroy && e4.destroy(), delete this.accessibility) : this.renderTo.setAttribute("aria-hidden", true);
          }
          function a2() {
            this.series.chart.accessibility && (this.series.chart.a11yDirty = true);
          }
          t3.i18nFormat = n.i18nFormat, t3.compose = function t4(d2, p2, b2, f2, x2, y2) {
            if (l.compose(d2), u.compose(f2), h.compose(d2, p2), c.compose(d2), m.compose(d2, b2, f2), n.compose(d2), r.compose(d2, x2), y2 && g.compose(d2, y2), P(C, t4)) {
              let t5 = d2.prototype;
              t5.updateA11yEnabled = o2, T(d2, "destroy", e3), T(d2, "render", i3), T(d2, "update", s2), ["addSeries", "init"].forEach((t6) => {
                T(d2, t6, function() {
                  this.a11yDirty = true;
                });
              }), ["afterApplyDrilldown", "drillupall"].forEach((t6) => {
                T(d2, t6, function() {
                  let t7 = this.accessibility;
                  t7 && !t7.zombie && t7.update();
                });
              }), T(b2, "update", a2), ["update", "updatedData", "remove"].forEach((t6) => {
                T(f2, t6, function() {
                  this.chart.accessibility && (this.chart.a11yDirty = true);
                });
              });
            }
          };
        }(D || (D = {})), k(true, w, y, { accessibility: { highContrastTheme: x }, lang: v }), D;
      }), i(e, "masters/modules/accessibility.src.js", [e["Core/Globals.js"], e["Accessibility/Accessibility.js"], e["Accessibility/AccessibilityComponent.js"], e["Accessibility/Utils/ChartUtilities.js"], e["Accessibility/Utils/HTMLUtilities.js"], e["Accessibility/KeyboardNavigationHandler.js"], e["Accessibility/Components/SeriesComponent/SeriesDescriber.js"]], function(t2, e2, i2, s, n, o, r) {
        t2.i18nFormat = e2.i18nFormat, t2.A11yChartUtilities = s, t2.A11yHTMLUtilities = n, t2.AccessibilityComponent = i2, t2.KeyboardNavigationHandler = o, t2.SeriesAccessibilityDescriber = r, e2.compose(t2.Chart, t2.Legend, t2.Point, t2.Series, t2.SVGElement, t2.RangeSelector);
      });
    });
  }
});
export default require_accessibility();
//# sourceMappingURL=highcharts_modules_accessibility.js.map
